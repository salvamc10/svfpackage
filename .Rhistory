p <- self$search_dmu(unlist(x))
phi <- self$calculate_dmu_phi(p)
phi_list <- c(phi_list, list(phi))
c_cell <- search_contiguous_cell(p)
c_cells <- c(c_cells, list(c_cell))
}
self$data_grid$phi <- phi_list
self$data_grid$c_cells <- c_cells
},
search_contiguous_cell = function(cell) {
con_c_list <- list()
cell <- as.list(cell)
for (dim in seq_along(cell)) {
value <- (cell[[dim]]) - 1
con_cell <- cell
if (value >= 0) {
con_cell[[dim]] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
)
}
# Definir la función de transformación
transformation <- function(x_i, t_k) {
z <- x_i - t_k
result <- rep(NA, length(z))
result[z < 0] <- -1
result[z == 0] <- 0
result[z > 0] <- 1
return(result)
}
# Definir la función para buscar la celda contigua
search_contiguous_cell <- function(cell) {
con_c_list <- list()
cell <- as.list(cell)
for (dim in seq_along(cell)) {
value <- (cell[[dim]]) - 1
con_cell <- cell
if (value >= 0) {
con_cell[[dim]] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
# Crear un conjunto de datos de ejemplo
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 1, 2),
y1 = c(2, 4, 3, 5)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- "y1"
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj$create_grid()
SVFGrid <- function(data, inputs, outputs, d) {
list(
data = data,
inputs = inputs,
outputs = outputs,
d = d,
df_grid = NULL,
initialize = function(...) {
self$initialize_grid()
},
create_grid <- function(grid_obj) {
grid_obj$df_grid <- data.frame(id_cell = character(),
value = character(),
phi = list())
x <- grid_obj$data[, grid_obj$inputs, drop = FALSE]
n_dim <- ncol(x)
knot_list <- list()
knot_index <- list()
for (col in seq_len(n_dim)) {
knot <- list()
knot_max <- max(x[, col])
knot_min <- min(x[, col])
amplitud <- (knot_max - knot_min) / grid_obj$d
for (i in seq_len(grid_obj$d + 1)) {
knot_i <- knot_min + i * amplitud
knot <- c(knot, knot_i)
}
knot_list <- c(knot_list, list(knot))
knot_index <- c(knot_index, list(seq_len(length(knot))))
}
grid_obj$df_grid$id_cell <- do.call(expand.grid, knot_index)
grid_obj$df_grid$value <- do.call(expand.grid, knot_list)
grid_obj$knot_list <- knot_list
calculate_df_grid(grid_obj)
},
calculate_dmu_phi = function(cell) {
phi <- lapply(1:length(self$df_grid$id_cell), function(i) {
value <- 0
for (j in seq_len(n_dim)) {
if (cell[[j]] >= self$df_grid$id_cell[i][[j]]) {
value <- 1
} else {
value <- 0
break
}
}
value
})
phi_list <- replicate(length(self$outputs), phi, simplify = FALSE)
return(phi_list)
},
calculate_df_grid = function() {
x_list <- self$df_grid$value
phi_list <- list()
c_cells <- list()
for (x in x_list) {
p <- self$search_dmu(x)
phi <- self$calculate_dmu_phi(p)
phi_list <- c(phi_list, list(phi))
}
for (i in seq_len(nrow(self$df_grid))) {
c_cell <- search_contiguous_cell(self$df_grid$id_cell[i, ])
c_cells <- c(c_cells, list(c_cell))
}
self$df_grid$phi <- phi_list
self$df_grid$c_cells <- c_cells
},
calculate_data_grid = function() {
self$data_grid <- self$data
x <- self$data_grid[, self$inputs, drop = FALSE]
x_list <- split(x, row(x))
phi_list <- list()
c_cells <- list()
for (x in x_list) {
p <- self$search_dmu(unlist(x))
phi <- self$calculate_dmu_phi(p)
phi_list <- c(phi_list, list(phi))
c_cell <- search_contiguous_cell(p)
c_cells <- c(c_cells, list(c_cell))
}
self$data_grid$phi <- phi_list
self$data_grid$c_cells <- c_cells
},
search_contiguous_cell = function(cell) {
con_c_list <- list()
cell <- as.list(cell)
for (dim in seq_along(cell)) {
value <- (cell[[dim]]) - 1
con_cell <- cell
if (value >= 0) {
con_cell[[dim]] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
)
}
# Definir la función de transformación
transformation <- function(x_i, t_k) {
z <- x_i - t_k
result <- rep(NA, length(z))
result[z < 0] <- -1
result[z == 0] <- 0
result[z > 0] <- 1
return(result)
}
# Definir la función para buscar la celda contigua
search_contiguous_cell <- function(cell) {
con_c_list <- list()
cell <- as.list(cell)
for (dim in seq_along(cell)) {
value <- (cell[[dim]]) - 1
con_cell <- cell
if (value >= 0) {
con_cell[[dim]] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
# Crear un conjunto de datos de ejemplo
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 1, 2),
y1 = c(2, 4, 3, 5)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- "y1"
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
create_grid(grid_obj)
SVFGrid <- function(data, inputs, outputs, d) {
list(
data = data,
inputs = inputs,
outputs = outputs,
d = d,
df_grid = NULL,
initialize = function(...) {
self$initialize_grid()
},
create_grid <- function(grid_obj) {
grid_obj$df_grid <- data.frame(id_cell = character(),
value = character(),
phi = list())
x <- grid_obj$data[, grid_obj$inputs, drop = FALSE]
n_dim <- ncol(x)
knot_list <- list()
knot_index <- list()
for (col in seq_len(n_dim)) {
knot <- list()
knot_max <- max(x[, col])
knot_min <- min(x[, col])
amplitud <- (knot_max - knot_min) / grid_obj$d
for (i in seq_len(grid_obj$d + 1)) {
knot_i <- knot_min + i * amplitud
knot <- c(knot, knot_i)
}
knot_list <- c(knot_list, list(knot))
knot_index <- c(knot_index, list(seq_len(length(knot))))
}
grid_obj$df_grid$id_cell <- do.call(expand.grid, knot_index)
grid_obj$df_grid$value <- do.call(expand.grid, knot_list)
grid_obj$knot_list <- knot_list
calculate_df_grid(grid_obj)
},
calculate_dmu_phi = function(cell) {
phi <- lapply(1:length(self$df_grid$id_cell), function(i) {
value <- 0
for (j in seq_len(n_dim)) {
if (cell[[j]] >= self$df_grid$id_cell[i][[j]]) {
value <- 1
} else {
value <- 0
break
}
}
value
})
phi_list <- replicate(length(self$outputs), phi, simplify = FALSE)
return(phi_list)
},
calculate_df_grid = function() {
x_list <- self$df_grid$value
phi_list <- list()
c_cells <- list()
for (x in x_list) {
p <- self$search_dmu(x)
phi <- self$calculate_dmu_phi(p)
phi_list <- c(phi_list, list(phi))
}
for (i in seq_len(nrow(self$df_grid))) {
c_cell <- search_contiguous_cell(self$df_grid$id_cell[i, ])
c_cells <- c(c_cells, list(c_cell))
}
self$df_grid$phi <- phi_list
self$df_grid$c_cells <- c_cells
},
calculate_data_grid = function() {
self$data_grid <- self$data
x <- self$data_grid[, self$inputs, drop = FALSE]
x_list <- split(x, row(x))
phi_list <- list()
c_cells <- list()
for (x in x_list) {
p <- self$search_dmu(unlist(x))
phi <- self$calculate_dmu_phi(p)
phi_list <- c(phi_list, list(phi))
c_cell <- search_contiguous_cell(p)
c_cells <- c(c_cells, list(c_cell))
}
self$data_grid$phi <- phi_list
self$data_grid$c_cells <- c_cells
},
search_contiguous_cell = function(cell) {
con_c_list <- list()
cell <- as.list(cell)
for (dim in seq_along(cell)) {
value <- (cell[[dim]]) - 1
con_cell <- cell
if (value >= 0) {
con_cell[[dim]] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
)
}
create_grid <- function(grid_obj) {
grid_obj$df_grid <- data.frame(id_cell = character(),
value = character(),
phi = list())
x <- grid_obj$data[, grid_obj$inputs, drop = FALSE]
n_dim <- ncol(x)
knot_list <- list()
knot_index <- list()
for (col in seq_len(n_dim)) {
knot <- list()
knot_max <- max(x[, col])
knot_min <- min(x[, col])
amplitud <- (knot_max - knot_min) / grid_obj$d
for (i in seq_len(grid_obj$d + 1)) {
knot_i <- knot_min + i * amplitud
knot <- c(knot, knot_i)
}
knot_list <- c(knot_list, list(knot))
knot_index <- c(knot_index, list(seq_len(length(knot))))
}
grid_obj$df_grid$id_cell <- do.call(expand.grid, knot_index)
grid_obj$df_grid$value <- do.call(expand.grid, knot_list)
grid_obj$knot_list <- knot_list
calculate_df_grid(grid_obj)
}
# Definir la función de transformación
transformation <- function(x_i, t_k) {
z <- x_i - t_k
result <- rep(NA, length(z))
result[z < 0] <- -1
result[z == 0] <- 0
result[z > 0] <- 1
return(result)
}
# Definir la función para buscar la celda contigua
search_contiguous_cell <- function(cell) {
con_c_list <- list()
cell <- as.list(cell)
for (dim in seq_along(cell)) {
value <- (cell[[dim]]) - 1
con_cell <- cell
if (value >= 0) {
con_cell[[dim]] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
# Crear un conjunto de datos de ejemplo
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 1, 2),
y1 = c(2, 4, 3, 5)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- "y1"
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
create_grid(grid_obj)
SVFGrid <- function(data, inputs, outputs, d) {
list(
data = data,
inputs = inputs,
outputs = outputs,
d = d,
df_grid = NULL,
initialize = function(...) {
self$initialize_grid()
},
create_grid <- function(grid_obj) {
grid_obj$df_grid <- data.frame(id_cell = character(),
value = character(),
phi = list())
x <- grid_obj$data[, grid_obj$inputs, drop = FALSE]
n_dim <- ncol(x)
knot_list <- list()
knot_index <- list()
for (col in seq_len(n_dim)) {
knot <- list()
knot_max <- max(x[, col])
knot_min <- min(x[, col])
amplitud <- (knot_max - knot_min) / grid_obj$d
for (i in seq_len(grid_obj$d + 1)) {
knot_i <- knot_min + i * amplitud
knot <- c(knot, knot_i)
}
knot_list <- c(knot_list, list(knot))
knot_index <- c(knot_index, list(seq_len(length(knot))))
}
grid_obj$df_grid$id_cell <- do.call(expand.grid, knot_index)
grid_obj$df_grid$value <- do.call(expand.grid, knot_list)
grid_obj$knot_list <- knot_list
calculate_df_grid(grid_obj)
},
calculate_dmu_phi = function(cell) {
phi <- lapply(1:length(self$df_grid$id_cell), function(i) {
value <- 0
for (j in seq_len(n_dim)) {
if (cell[[j]] >= self$df_grid$id_cell[i][[j]]) {
value <- 1
} else {
value <- 0
break
}
}
value
})
phi_list <- replicate(length(self$outputs), phi, simplify = FALSE)
return(phi_list)
},
calculate_df_grid = function() {
x_list <- self$df_grid$value
phi_list <- list()
c_cells <- list()
for (x in x_list) {
p <- self$search_dmu(x)
phi <- self$calculate_dmu_phi(p)
phi_list <- c(phi_list, list(phi))
}
for (i in seq_len(nrow(self$df_grid))) {
c_cell <- search_contiguous_cell(self$df_grid$id_cell[i, ])
c_cells <- c(c_cells, list(c_cell))
}
self$df_grid$phi <- phi_list
self$df_grid$c_cells <- c_cells
},
calculate_data_grid = function() {
self$data_grid <- self$data
x <- self$data_grid[, self$inputs, drop = FALSE]
x_list <- split(x, row(x))
phi_list <- list()
c_cells <- list()
for (x in x_list) {
p <- self$search_dmu(unlist(x))
phi <- self$calculate_dmu_phi(p)
phi_list <- c(phi_list, list(phi))
c_cell <- search_contiguous_cell(p)
c_cells <- c(c_cells, list(c_cell))
}
self$data_grid$phi <- phi_list
self$data_grid$c_cells <- c_cells
},
search_contiguous_cell = function(cell) {
con_c_list <- list()
cell <- as.list(cell)
for (dim in seq_along(cell)) {
value <- (cell[[dim]]) - 1
con_cell <- cell
if (value >= 0) {
con_cell[[dim]] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
)
}
create_grid <- function(grid_obj) {
grid_obj$df_grid <- data.frame(id_cell = character(),
value = character(),
phi = list())
x <- grid_obj$data[, grid_obj$inputs, drop = FALSE]
n_dim <- ncol(x)
knot_list <- list()
knot_index <- list()
for (col in seq_len(n_dim)) {
knot <- list()
knot_max <- max(x[, col])
knot_min <- min(x[, col])
amplitud <- (knot_max - knot_min) / grid_obj$d
for (i in seq_len(grid_obj$d + 1)) {
knot_i <- knot_min + i * amplitud
knot <- c(knot, knot_i)
}
knot_list <- c(knot_list, list(knot))
knot_index <- c(knot_index, list(seq_len(length(knot))))
}
grid_obj$df_grid$id_cell <- do.call(expand.grid, knot_index)
grid_obj$df_grid$value <- do.call(expand.grid, knot_list)
grid_obj$knot_list <- knot_list
calculate_df_grid(grid_obj)
}
# Definir la función de transformación
transformation <- function(x_i, t_k) {
z <- x_i - t_k
result <- rep(NA, length(z))
result[z < 0] <- -1
result[z == 0] <- 0
result[z > 0] <- 1
return(result)
}
# Definir la función para buscar la celda contigua
search_contiguous_cell <- function(cell) {
con_c_list <- list()
cell <- as.list(cell)
for (dim in seq_along(cell)) {
value <- (cell[[dim]]) - 1
con_cell <- cell
if (value >= 0) {
con_cell[[dim]] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
# Crear un conjunto de datos de ejemplo
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 1, 2),
y1 = c(2, 4, 3, 5)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- "y1"
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
create_grid(grid_obj)
