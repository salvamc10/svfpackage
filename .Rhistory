print(sol$solution)
print(sol$objval)
# Cargar el paquete lpSolve
library(lpSolve)
# Definir los coeficientes de la función objetivo
objective <- c(3, 2)
# Definir las restricciones del problema
# Las restricciones deben ser en forma de <=, por lo tanto, se ajusta la primera restricción multiplicándola por -1
constraints <- matrix(c(2, 1, 2, 3, 3, 1), nrow = 3, byrow = TRUE)
constraint_rhs <- c(-0.001, 1)  # Usar un valor pequeño en lugar de 0 para representar el "mayor que 0"
# Definir las direcciones de las restricciones
constraint_dir <- c(">=", "<=")
# Resolver el problema de maximización
sol <- lp("max", objective, constraints, constraint_dir, constraint_rhs)
# Mostrar el resultado
print(sol$solution)
print(sol$objval)
# Cargar el paquete lpSolve
library(lpSolve)
# Definir los coeficientes de la función objetivo
objective.coef <- c(3, 2)
# Definir las restricciones del modelo
# Matriz con los coeficientes de las restricciones
const.mat <- matrix(c(2, 1,   # Coeficientes de la primera restricción
2, 3,   # Coeficientes de la segunda restricción
3, 1),  # Coeficientes de la tercera restricción
nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
const.rhs <- c(18, 42, 24)
# Direcciones de las restricciones (<=)
const.dir <- c("<=", "<=", "<=")
# Definir los límites de las variables (no negativas)
var.limits <- c(0, Inf)
# Crear el modelo en lpSolve
lp.model <- lp(direction = "max",
objective.in = objective.coef,
const.mat = const.mat,
const.dir = const.dir,
const.rhs = const.rhs,
all.int = FALSE,
all.bin = FALSE)
# Verificar el resultado
if(lp.model$status == 0) {
print("Solución óptima encontrada:")
print(paste("Valor objetivo:", lp.model$objval))
print(paste("Valores de las variables:", toString(lp.model$solution)))
} else {
print("No se encontró solución.")
}
library(ROI)
library(ROI.plugin.glpk)
# Instalar y cargar las librerías necesarias
if (!requireNamespace("ROI", quietly = TRUE)) install.packages("ROI")
if (!requireNamespace("ROI.plugin.lpsolve", quietly = TRUE)) install.packages("ROI.plugin.lpsolve")
library(ROI)
library(ROI.plugin.lpsolve)
# Definir los coeficientes de la función objetivo
objective.coef <- c(3, 2)
# Definir las restricciones del modelo
# Matriz con los coeficientes de las restricciones
const.mat <- matrix(c(2, 1,   # Coeficientes de la primera restricción
2, 3,   # Coeficientes de la segunda restricción
3, 1),  # Coeficientes de la tercera restricción
nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
const.rhs <- c(18, 42, 24)
# Direcciones de las restricciones
const.dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización usando ROI
lp.model <- OP(objective = L_objective(coef = objective.coef, maximum = TRUE),
constraints = L_constraint(L = const.mat, dir = const.dir, rhs = const.rhs),
bounds = V_bound(li = 1:2, ui = 1:2, lb = c(0, 0), ub = c(Inf, Inf)),
types = rep("C", 2))
# Instalar y cargar las librerías necesarias
if (!requireNamespace("ROI", quietly = TRUE)) install.packages("ROI")
if (!requireNamespace("ROI.plugin.lpsolve", quietly = TRUE)) install.packages("ROI.plugin.lpsolve")
library(ROI)
library(ROI.plugin.lpsolve)
# Definir los coeficientes de la función objetivo
objective.coef <- c(3, 2)
# Definir las restricciones del modelo
# Matriz con los coeficientes de las restricciones
const.mat <- matrix(c(2, 1,   # Coeficientes de la primera restricción
2, 3,   # Coeficientes de la segunda restricción
3, 1),  # Coeficientes de la tercera restricción
nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
const.rhs <- c(18, 42, 24)
# Direcciones de las restricciones
const.dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización usando ROI
lp.model <- OP(objective = L_objective(coef = objective.coef, maximum = TRUE),
constraints = L_constraint(L = const.mat, dir = const.dir, rhs = const.rhs),
bounds = V_bound(li = 1:2, ui = 1:2, lb = c(0, 0), ub = c(Inf, Inf)),
types = rep("C", 2))
library(ROI)
library(ROI.plugin.lpsolve)
# Definir los coeficientes de la función objetivo
objective.coef <- c(3, 2)
# Definir las restricciones del modelo
# Matriz con los coeficientes de las restricciones
const.mat <- matrix(c(2, 1,   # Coeficientes de la primera restricción
2, 3,   # Coeficientes de la segunda restricción
3, 1),  # Coeficientes de la tercera restricción
nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
const.rhs <- c(18, 42, 24)
# Direcciones de las restricciones
const.dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización usando ROI
lp.model <- OP(objective = L_objective(objective.coef),
constraints = L_constraint(L = const.mat, dir = const.dir, rhs = const.rhs),
bounds = V_bound(li = 1:2, ui = 1:2, lb = c(0, 0), ub = c(Inf, Inf)),
types = rep("C", 2),
maximum = TRUE)  # Aquí especificamos que es un problema de maximización
# Resolver el modelo
solution <- ROI_solve(lp.model, solver = "lpsolve")
# Verificar el resultado
if (solution$status == 0) {
cat("Solución óptima encontrada:\n")
cat(sprintf("Valor objetivo: %f\n", solution$objval))
cat(sprintf("Valores de las variables: %s\n", toString(solution$solution)))
} else {
cat("No se encontró solución.\n")
}
# Instalar y cargar las librerías necesarias
if (!requireNamespace("ROI", quietly = TRUE)) install.packages("ROI")
if (!requireNamespace("ROI.plugin.lpsolve", quietly = TRUE)) install.packages("ROI.plugin.lpsolve")
library(ROI)
library(ROI.plugin.lpsolve)
# Definir los coeficientes de la función objetivo
objective.coef <- c(3, 2)
# Definir las restricciones del modelo
# Matriz con los coeficientes de las restricciones
const.mat <- matrix(c(2, 1,   # Coeficientes de la primera restricción
2, 3,   # Coeficientes de la segunda restricción
3, 1),  # Coeficientes de la tercera restricción
nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
const.rhs <- c(18, 42, 24)
# Direcciones de las restricciones
const.dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización usando ROI
lp.model <- OP(objective = L_objective(objective.coef),
constraints = L_constraint(L = const.mat, dir = const.dir, rhs = const.rhs),
bounds = V_bound(li = 1:2, ui = 1:2, lb = rep(0, 2), ub = rep(Inf, 2)),
types = rep("C", 2),
maximum = TRUE)  # Especificamos que es un problema de maximización
# Resolver el modelo
solution <- ROI_solve(lp.model, solver = "lpsolve")
# Verificar el resultado
if (solution$status == 0) {
cat("Solución óptima encontrada:\n")
cat(sprintf("Valor objetivo: %f\n", solution$objval))
cat(sprintf("Valores de las variables: %s\n", toString(solution$solution)))
} else {
cat("No se encontró solución.\n")
}
# Cargar las bibliotecas necesarias
if (!requireNamespace("ROI", quietly = TRUE)) install.packages("ROI")
if (!requireNamespace("ROI.plugin.lpsolve", quietly = TRUE)) install.packages("ROI.plugin.lpsolve")
library(ROI)
library(ROI.plugin.lpsolve)
# Definir los coeficientes de la función objetivo
objective.coef <- c(3, 2)
# Definir las restricciones del modelo
# Matriz con los coeficientes de las restricciones
const.mat <- matrix(c(2, 1,   # Coeficientes de la primera restricción
2, 3,   # Coeficientes de la segunda restricción
3, 1),  # Coeficientes de la tercera restricción
nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
const.rhs <- c(18, 42, 24)
# Direcciones de las restricciones (<=)
const.dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización usando ROI
lp.model <- OP(objective = L_objective(objective.coef, maximum = TRUE),  # Maximizar la función
constraints = L_constraint(L = const.mat, dir = const.dir, rhs = const.rhs),
bounds = V_bound(lb = c(0, 0), ub = c(Inf, Inf)),  # X1, X2 ≥ 0
types = c("C", "C"))  # Ambas variables son continuas
# Instalar y cargar las bibliotecas necesarias
if (!requireNamespace("ROI", quietly = TRUE)) install.packages("ROI")
if (!requireNamespace("ROI.plugin.glpk", quietly = TRUE)) install.packages("ROI.plugin.glpk")
library(ROI)
library(ROI.plugin.glpk)
# Definir los coeficientes de la función objetivo
objective.coef <- c(5, 4)
# Definir las restricciones del modelo
# Matriz con los coeficientes de las restricciones
const.mat <- matrix(c(3, 2,   # Coeficientes de la primera restricción
4, 3,   # Coeficientes de la segunda restricción
1, 1),  # Coeficientes de la tercera restricción
nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
const.rhs <- c(18, 24, 8)
# Direcciones de las restricciones (<=)
const.dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización usando ROI
lp.model <- OP(objective = L_objective(objective.coef, maximum = TRUE),  # Maximizar la función
constraints = L_constraint(L = const.mat, dir = const.dir, rhs = const.rhs),
bounds = V_bound(lb = c(0, 0), ub = c(Inf, Inf)),  # x1, x2 ≥ 0
types = c("C", "C"))  # Ambas variables son continuas
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(20, 30)
# Matriz de restricciones
mat <- matrix(c(2, 1, 1, 2), nrow = 2, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(100, 100)
# Tipo de restricciones
dir <- c("<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::solve(lp, solver = "glpk")
install.packages("ROI")
install.packages("ROI.plugin.glpk")
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(20, 30)
# Matriz de restricciones
mat <- matrix(c(2, 1, 1, 2), nrow = 2, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(100, 100)
# Tipo de restricciones
dir <- c("<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::solve(lp, solver = "glpk")
install.packages("ROI.plugin.glpk")
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(20, 30)
# Matriz de restricciones
mat <- matrix(c(2, 1, 1, 2), nrow = 2, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(100, 100)
# Tipo de restricciones
dir <- c("<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::solve(lp, solver = "glpk")
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(20, 30)
# Matriz de restricciones
mat <- matrix(c(2, 1, 1, 2), nrow = 2, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(100, 100)
# Tipo de restricciones
dir <- c("<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::solve(lp, solver = "glpk")
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(20, 30)
# Matriz de restricciones
mat <- matrix(c(2, 1, 1, 2), nrow = 2, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(100, 100)
# Tipo de restricciones
dir <- c("<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::ROI_solve(lp, solver = "glpk")
# Ver resultados
print(solution)
# Cargar las bibliotecas necesarias
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(3, 2)
# Matriz de restricciones
mat <- matrix(c(2, 1, 2, 3, 3, 1), nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(18, 42, 24)
# Tipo de restricciones
dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::ROI_solve(lp, solver = "glpk")
# Ver resultados
print(solution)
# Cargar las bibliotecas necesarias
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(3, 2)
# Matriz de restricciones
mat <- matrix(c(2, 1, 2, 3, 3, 1), nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(18, 42, 24)
# Tipo de restricciones
dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::ROI_solve(lp, solver = "glpk")
# Ver resultados
print(solution)
print(solution$objval)
# Cargar las bibliotecas necesarias
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(3, 2)
# Matriz de restricciones
mat <- matrix(c(2, 1, 2, 3, 3, 1), nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(18, 42, 24)
# Tipo de restricciones
dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::ROI_solve(lp, solver = "glpk")
# Ver resultados
if (solution$status == "optimal") {
optimal_value <- solution$objval
optimal_x1 <- solution$solution[1]
optimal_x2 <- solution$solution[2]
cat("La solución óptima es Z =", optimal_value, "\n")
cat("Se obtiene para los valores de X1 =", optimal_x1, "y X2 =", optimal_x2)
} else {
cat("No se encontró una solución óptima.")
}
# Cargar las bibliotecas necesarias
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(3, 2)
# Matriz de restricciones
mat <- matrix(c(2, 1, 2, 3, 3, 1), nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(18, 42, 24)
# Tipo de restricciones
dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::ROI_solve(lp, solver = "glpk")
# Ver resultados
if (solution$status == "optimal") {
optimal_value <- solution$objval
optimal_x1 <- solution$solution[1]
optimal_x2 <- solution$solution[2]
cat("La solución óptima es Z =", optimal_value, "\n")
cat("Se obtiene para los valores de X1 =", optimal_x1, "y X2 =", optimal_x2)
} else {
cat("No se encontró una solución óptima.")
}
# Cargar las bibliotecas necesarias
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(3, 2)
# Matriz de restricciones
mat <- matrix(c(2, 1, 2, 3, 3, 1), nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(18, 42, 24)
# Tipo de restricciones
dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::ROI_solve(lp, solver = "glpk")
# Imprimir la estructura del objeto de solución
print(solution)
print(str(solution))
# Cargar las bibliotecas necesarias
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(3, 2)
# Matriz de restricciones
mat <- matrix(c(2, 1, 2, 3, 3, 1), nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(18, 42, 24)
# Tipo de restricciones
dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::ROI_solve(lp, solver = "glpk")
# Imprimir la estructura del objeto de solución
print(solution)
print(solution$solution)
# Cargar las bibliotecas necesarias
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(3, 2)
# Matriz de restricciones
mat <- matrix(c(2, 1, 2, 3, 3, 1), nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(18, 42, 24)
# Tipo de restricciones
dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::ROI_solve(lp, solver = "glpk")
# Ver resultados
print(solution)
print(solution$objval)
# Cargar las bibliotecas necesarias
library(ROI)
library(ROI.plugin.glpk)
# Definir las coeficientes de la función objetivo
obj <- c(3, 2)
# Matriz de restricciones
mat <- matrix(c(2, 1, 2, 3, 3, 1), nrow = 3, byrow = TRUE)
# Lado derecho de las restricciones
rhs <- c(18, 42, 24)
# Tipo de restricciones
dir <- c("<=", "<=", "<=")
# Crear el modelo de optimización
lp <- ROI::OP(objective = obj,
constraints = L_constraint(L = mat, dir = dir, rhs = rhs),
types = c("C", "C"),
maximum = TRUE)
# Resolver el modelo usando el solver GLPK
solution <- ROI::ROI_solve(lp, solver = "glpk")
# Ver resultados
print(solution)
print(solution$objval)
print(solution$solution)
library(ROI)
library(ROI.plugin.glpk)
# Definir el constructor de SVF
SVF <- function(method, inputs, outputs, data, C, eps, d) {
obj <- list(method = method, inputs = inputs, outputs = outputs, data = data,
C = C, eps = eps, d = d, model = NULL, solution = NULL)
class(obj) <- "SVF"
return(obj)
}
# Método para modificar el modelo
modify_model <- function(obj, c, eps) {
# Aquí asumimos que obj$model está previamente inicializado y configurado
# Esta parte necesitará ser adaptada según cómo se crea el modelo originalmente
requireNamespace("ROI", quietly = TRUE)
n_obs <- nrow(obj$data)
# Suponiendo que tenemos que reconfigurar todo el modelo:
obj$model <- ROI::OP(objective = ROI_objective(coefs = rep(1, length(obj$inputs)), maximum = FALSE),
constraints = L_constraint(L = matrix(rep(1, length(obj$inputs) * n_obs), nrow = n_obs),
dir = rep("<=", n_obs),
rhs = rep(eps, n_obs)),
types = rep("C", length(obj$inputs)))
# Actualizar parámetros específicos si es necesario
# Aquí deberías implementar lógicas específicas basadas en la estructura de tu modelo
return(obj)
}
# Método para obtener estimaciones
get_estimation <- function(obj, dmu) {
if (length(dmu) != length(obj$inputs)) {
stop("El número de inputs de la DMU no coincide con el número de inputs del problema.")
}
# Asumir que obj$solution ya contiene resultados necesarios para la estimación
# Implementar la lógica para calcular estimaciones basadas en dmu y obj$solution
return(list())  # Retorna una lista con estimaciones
}
# Crear instancia de SVF
svf_model <- SVF("some_method", c("input1", "input2"), c("output1"), data.frame(input1 = 1:10, input2 = 11:20), C = 0.1, eps = 0.01, d = 2)
# Modificar el modelo
svf_model <- modify_model(svf_model, 0.5, 0.02)
