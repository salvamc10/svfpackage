p <- search_dmu.GRID(grid, cell)
phi <- calculate_dmu_phi(grid, p)[[1]]
c_cells <- search_contiguous_cell(p)
phi_list[[i]] <- list(phi)
c_cells_list[[i]] <- c_cells
}
grid$df_grid$phi <- phi_list
grid$df_grid$c_cells <- c_cells_list
return(grid)
}
#' Método para añadir al dataframe grid el valor de la transformada de cada observación
#'
#' Esta función procesa cada observación del data_grid basándose en las columnas especificadas en inputs,
#' calculando valores phi y celdas contiguas (c_cells) y actualizando el objeto grid con estos resultados.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return 0bjeto grid modificado con los resultados de phi y c_cells añadidos.
#'
#' @example examples/example_data.R
#'
#' @export
calculate_data_grid <- function(grid) {
grid$data_grid <- grid$data[, c(grid$inputs, grid$outputs), drop = FALSE]
n_rows <- nrow(grid$data_grid)
phi_list <- vector("list", n_rows)
c_cells_list <- vector("list", n_rows)
for (i in seq_len(n_rows)) {
x <- as.numeric(grid$data_grid[i, grid$inputs, drop = FALSE])
p <- search_dmu.GRID(grid, x)
phi <- calculate_dmu_phi(grid, p)
c_cells <- search_contiguous_cell(p)
phi_list[[i]] <- phi
c_cells_list[[i]] <- c_cells
}
grid$data_grid$phi <- phi_list
grid$data_grid$c_cells <- c_cells_list
return(grid)
}
#' Buscar celdas contiguas en SVFGrid
#'
#' Esta función identifica y retorna las celdas contiguas a una celda especificada
#' en el grid. Las celdas contiguas son aquellas que comparten al menos un borde
#' o punto con la celda especificada.
#'
#' @param cell Vector que especifica la posición de la celda en el grid.
#'
#' @return Una lista de celdas contiguas a la especificada.
#'
#' @example examples/example_contiguous.R
#'
#' @export
search_contiguous_cell <- function(cell) {
con_c_list <- list()
for (dim in seq_along(cell)) {
value <- cell[dim] - 1
if (value >= 1) {
con_cell <- cell
con_cell[dim] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
source("~/Documents/GitHub/svfpackage/R/grid.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj <- create_grid.SVFGrid(grid_obj)
# Imprimimos la knot_list
cat("knot_list:\n")
for (i in seq_along(grid_obj$knot_list)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_list)[i], "): "),
paste(sprintf("%.1f", grid_obj$knot_list[[i]]), collapse = ", "), "\n")
}
# Realizar una búsqueda en el grid para una observación
dmu <- c(1, 3 )
position <- search_dmu.GRID(grid_obj, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Ejemplo de búsqueda de celda contigua
cell <- c(1, 1)
contiguous_cells <- search_contiguous_cell(cell)
print(paste("Celdas contiguas: (", paste(contiguous_cells, collapse = ", "), ")", sep = ""))
# Ejemplo del calculo de phi para una celda dada
cell <- c(1, 3)
phi_list <- calculate_dmu_phi(grid_obj, cell)
print("Vector phi para la celda dada:")
print(phi_list)
print_df_grid <- function(df_grid) {
print("DF grid completo:")
temp_df <- data.frame(
id_cell = apply(df_grid$id_cells, 1, function(row) paste0("(", paste(row, collapse = ", "), ")")),
value = apply(df_grid$values, 1, function(row) paste0("(", paste(sprintf("%.1f", row), collapse = ", "), ")")),
phi = sapply(df_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse=" "))),
c_cells = sapply(df_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_df_grid(grid_obj$df_grid)
print_data_grid <- function(data_grid) {
print("Data grid completo:")
temp_df <- data.frame(
x1 = data_grid$x1,
x2 = data_grid$x2,
phi = sapply(data_grid$phi, function(phi) sprintf("[%s]", paste(phi, collapse = " "))),
c_cells = sapply(data_grid$c_cells, function(cells) if (length(cells) > 0) {
paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ")
} else "[]")
)
print(temp_df)
}
print_data_grid(grid_obj$data_grid)
#' Crea una nueva instancia de la clase SVF
#'
#' Esta función inicializa un objeto SVF con los parámetros proporcionados,
#' encapsulando un modelo SVF con las especificaciones de entrada y salida,
#' junto con los hiperparámetros del modelo.
#'
#' @param method Método SVF que se quiere utilizar.
#' @param inputs Inputs a evaluar en el conjunto de datos.
#' @param outputs Outputs a evaluar en el conjunto de datos.
#' @param data Conjunto de datos a evaluar.
#' @param C Valores del hiperparámetro C del modelo.
#' @param eps Valores del hiperparámetro épsilon del modelo.
#' @param d Valor del hiperparámetro d del modelo.
#'
#' @return Un objeto de la clase 'SVF'.
#'
#' @example examples/example_svf.R
#'
#' @export
SVF <- function(method, inputs, outputs, data, C, eps, d) {
structure(list(method = method, inputs = inputs, outputs = outputs, data = data, C = C, eps = eps, d = d), class = "SVF")
}
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
C <- 1
eps <- 0
d <- 2
method <- 'SVF'
# Crear una instancia de la clase SVF
svf <- SVF(method, inputs, outputs, datos2, C, eps, d)
source("~/Documents/GitHub/svfpackage/R/svf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
C <- 1
eps <- 0
d <- 2
method <- 'SVF'
# Crear una instancia de la clase SVF
svf <- SVF(method, inputs, outputs, data, C, eps, d)
# Imprimir la instancia
print(svf)
#' Crea un objeto SSVF
#'
#' @param method Método SVF a utilizar.
#' @param inputs Inputs a evaluar en el conjunto de datos.
#' @param outputs Outputs a evaluar en el conjunto de datos.
#' @param data Conjunto de datos a evaluar.
#' @param c Valores del hiperparámetro C del modelo.
#' @param eps Valores del hiperparámetro épsilon del modelo.
#' @param d Valor del hiperparámetro d del modelo.
#'
#' @return Un objeto de clase SSVF.
#'
#' @example examples/example_ssvf.R
#'
#' @export
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
#' Entrena el modelo SSVF
#'
#' Esta función configura y resuelve el modelo SSVF utilizando programación lineal mixta.
#'
#' @param svf Objeto SSVF.
#'
#' @return El objeto SSVF con el modelo resuelto añadido.
#'
#' @example examples/example_train.R
#'
#' @import Rcplex
#'
#' @export
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
total_variables <- n_out * n_var + n_out * n_obs
cvec <- c(rep(1, n_out * n_var), rep(svf$c, n_out * n_obs))
Amat <- matrix(0, nrow = 2 * n_out * n_obs, ncol = total_variables)
bvec <- vector("numeric", length = 2 * n_out * n_obs)
sense <- rep("L", 2 * n_out * n_obs)
for (out in 1:n_out) {
for (obs in 1:n_obs) {
phi_vector <- svf$grid$data_grid$phi[[obs]][[out]]
row_index1 <- (out - 1) * 2 * n_obs + (obs - 1) * 2 + 1
row_index2 <- row_index1 + 1
w_indices <- ((out - 1) * n_var + 1):((out - 1) * n_var + n_var)
xi_index <- n_out * n_var + (out - 1) * n_obs + obs
Amat[row_index1, w_indices] <- -phi_vector
Amat[row_index2, w_indices] <- phi_vector
Amat[row_index2, xi_index] <- -1
bvec[row_index1] <- -y[obs, out]
bvec[row_index2] <- y[obs, out] + svf$eps
}
}
svf$model <- Rcplex(cvec = cvec, Amat = Amat, bvec = bvec, sense = sense, objsense = "min")
return(svf)
}
#' Resolver el modelo SSVF
#'
#' Esta función extrae las soluciones del modelo SSVF después de que ha sido resuelto.
#'
#' @param svf Objeto SSVF con un modelo ya entrenado.
#'
#' @return Una lista conteniendo las soluciones para las variables 'w' y 'xi'.
#'
#' @example examples/example_solve.R
#'
#' @export
solve <- function(svf) {
solution <- svf$model$xopt
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
n_out <- length(svf$outputs)
n_obs <- nrow(svf$data)
n_w_vars <- n_out * n_var
n_xi_vars <- n_out * n_obs
w_solution <- solution[1:n_w_vars]
xi_solution <- solution[(n_w_vars + 1):(n_w_vars + n_xi_vars)]
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_var + 1
end_index <- out * n_var
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
cat("Solucion para w variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_w[[out]], collapse=", ")))
}
cat("Solucion para xi variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_xi[[out]], collapse=", ")))
}
return(list(w = mat_w, xi = mat_xi))
Rcplex.close()
}
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
source("~/Documents/GitHub/svfpackage/R/svf.R")
library(Rcplex)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(1, 4, 8, 5), y2 = c(1, 3, 5, 2), y3 = c(1, 4, 3, 5))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2", "y3")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
library(Rcplex)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(1, 4, 8, 5), y2 = c(1, 3, 5, 2), y3 = c(1, 4, 3, 5))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2", "y3")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
library(Rcplex)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(1, 4, 8, 5), y2 = c(1, 3, 5, 2))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/tests/test_functions.R")
source("~/Documents/GitHub/svfpackage/tests/test_functions.R")
source("~/Documents/GitHub/svfpackage/tests/test_functions.R")
source("~/Documents/GitHub/svfpackage/R/grid.R")
library(ggplot2)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
grid_instance <- GRID(data, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(3, 4)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
C <- 1
eps <- 0
d <- 2
method <- 'SVF'
# Crear una instancia de la clase SVF
svf <- SVF(method, inputs, outputs, data, C, eps, d)
# Imprimir la instancia
print(svf)
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj <- create_grid.SVFGrid(grid_obj)
# Imprimimos la knot_list
cat("knot_list:\n")
for (i in seq_along(grid_obj$knot_list)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_list)[i], "): "),
paste(sprintf("%.1f", grid_obj$knot_list[[i]]), collapse = ", "), "\n")
}
# Realizar una búsqueda en el grid para una observación
dmu <- c(1, 3 )
position <- search_dmu.GRID(grid_obj, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Ejemplo de búsqueda de celda contigua
cell <- c(1, 1)
contiguous_cells <- search_contiguous_cell(cell)
print(paste("Celdas contiguas: (", paste(contiguous_cells, collapse = ", "), ")", sep = ""))
# Ejemplo del calculo de phi para una celda dada
cell <- c(1, 3)
phi_list <- calculate_dmu_phi(grid_obj, cell)
print("Vector phi para la celda dada:")
print(phi_list)
print_df_grid <- function(df_grid) {
print("DF grid completo:")
temp_df <- data.frame(
id_cell = apply(df_grid$id_cells, 1, function(row) paste0("(", paste(row, collapse = ", "), ")")),
value = apply(df_grid$values, 1, function(row) paste0("(", paste(sprintf("%.1f", row), collapse = ", "), ")")),
phi = sapply(df_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse=" "))),
c_cells = sapply(df_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_df_grid(grid_obj$df_grid)
print_data_grid <- function(data_grid) {
print("Data grid completo:")
temp_df <- data.frame(
x1 = data_grid$x1,
x2 = data_grid$x2,
phi = sapply(data_grid$phi, function(phi) sprintf("[%s]", paste(phi, collapse = " "))),
c_cells = sapply(data_grid$c_cells, function(cells) if (length(cells) > 0) {
paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ")
} else "[]")
)
print(temp_df)
}
print_data_grid(grid_obj$data_grid)
source("~/Documents/GitHub/svfpackage/R/svf_functions.R")
source("~/Documents/GitHub/svfpackage/R/svf_functions.R")
library(Rcplex)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf_functions.R")
library(Rcplex)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
print(solution_svf)
