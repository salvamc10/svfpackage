}
# Imprime knot_list y knot_index
cat("knot_list:\n")
print(knot_list)
cat("knot_index:\n")
print(knot_index)
# Genera todas las combinaciones de knot_index y knot_list
combinations <- expand.grid(knot_index)
knot_values <- do.call(expand.grid, knot_list)
# Combina manualmente las listas de knot_index y knot_list
grid_instance$df_grid <- data.frame(
id_cell = sapply(1:nrow(combinations), function(i) unlist(combinations[i,])),
value = sapply(1:nrow(knot_values), function(i) unlist(knot_values[i,]))
)
# Calcula la longitud de celdas contiguas
grid_instance$df_grid$c_cells <- sapply(grid_instance$df_grid$id_cell, search_contiguous_cell)
# Calcula la transformación phi
grid_instance$df_grid$phi <- apply(grid_instance$df_grid$id_cell, 1, function(x) calculate_dmu_phi(grid_instance, x))
grid_instance$knot_list <- knot_list
grid_instance$calculate_df_grid()
grid_instance$calculate_data_grid()
}
# Método para calcular la transformación de phi para una celda dada
grid_instance$calculate_dmu_phi <- function(cell) {
phi <- list()
n_dim <- length(cell)
for (i in 1:nrow(grid_instance$df_grid)) {
value <- 0
for (j in 1:n_dim) {
if (cell[j] >= grid_instance$df_grid$id_cell[i, j]) {
value <- 1
} else {
value <- 0
break
}
}
phi[[i]] <- rep(value, length(outputs))
}
return(phi)
}
# Método para calcular el valor de la transformada de cada observación en el grid
grid_instance$calculate_df_grid <- function() {
phi_list <- list()
c_cells <- list()
for (i in 1:nrow(grid_instance$df_grid)) {
p <- grid_instance$search_dmu(as.list(grid_instance$df_grid$value[i, ]))
phi <- grid_instance$calculate_dmu_phi(p)
phi_list[[i]] <- phi
c_cell <- search_contiguous_cell(grid_instance$df_grid$id_cell[i, ])
c_cells[[i]] <- c_cell
}
grid_instance$df_grid$phi <- phi_list
grid_instance$df_grid$c_cells <- c_cells
}
# Método para calcular la transformada de cada observación en el grid
grid_instance$calculate_data_grid <- function() {
data_grid <- grid_instance$data
phi_list <- list()
c_cells <- list()
for (i in 1:nrow(data_grid)) {
x <- data_grid[i, inputs]
p <- grid_instance$search_dmu(as.list(x))
phi <- grid_instance$calculate_dmu_phi(p)
phi_list[[i]] <- phi
c_cell <- search_contiguous_cell(p)
c_cells[[i]] <- c_cell
}
data_grid$phi <- phi_list
data_grid$c_cells <- c_cells
grid_instance$data_grid <- data_grid
}
return(grid_instance)
}
# Método para buscar celdas contiguas
search_contiguous_cell <- function(cell) {
con_c_list <- list()
for (dim in seq_along(cell)) {
value <- cell[dim] - 1
con_cell <- cell
if (value >= 0) {
con_cell[dim] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
# Crear un conjunto de datos de ejemplo
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 1, 2),
y1 = c(2, 4, 3, 5)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj$create_grid()
# Cargar la clase grid y sus funciones asociadas
source("~/Documents/GitHub/svfpackage/R/grid.R")
# Definir la clase SVFGrid como una extensión de la clase GRID
SVFGrid <- function(data, inputs, outputs, d) {
# Llamar al constructor de la clase GRID
grid_instance <- GRID$data$new(data, inputs, outputs, d)
# Agregar atributos específicos de SVFGrid
grid_instance$df_grid <- NULL
grid_instance$knot_list <- NULL
# Métodos de la clase SVFGrid
# Método para crear el grid
grid_instance$create_grid <- function() {
x <- grid_instance$data[, inputs]
n_dim <- ncol(x)
knot_list <- vector("list", n_dim)
knot_index <- vector("list", n_dim)
# Calcula knot_list y knot_index
for (col in 1:n_dim) {
knot_min <- min(x[, col])
knot_max <- max(x[, col])
amplitud <- (knot_max - knot_min) / grid_instance$d
knot <- seq(knot_min, knot_max, by = amplitud)
knot_list[[col]] <- knot
knot_index[[col]] <- 0:grid_instance$d
}
# Genera todas las combinaciones de knot_index y knot_list
combinations <- expand.grid(knot_index)
knot_values <- do.call(expand.grid, knot_list)
# Combina manualmente las listas de knot_index y knot_list
grid_instance$df_grid <- data.frame(
id_cell = sapply(1:nrow(combinations), function(i) unlist(combinations[i,])),
value = sapply(1:nrow(knot_values), function(i) unlist(knot_values[i,]))
)
# Calcula la longitud de celdas contiguas
grid_instance$df_grid$c_cells <- sapply(grid_instance$df_grid$id_cell, search_contiguous_cell)
# Calcula la transformación phi
grid_instance$df_grid$phi <- apply(grid_instance$df_grid$id_cell, 1, function(x) calculate_dmu_phi(grid_instance, x))
grid_instance$knot_list <- knot_list
grid_instance$calculate_df_grid()
grid_instance$calculate_data_grid()
}
# Método para calcular la transformación de phi para una celda dada
grid_instance$calculate_dmu_phi <- function(cell) {
phi <- list()
n_dim <- length(cell)
for (i in 1:nrow(grid_instance$df_grid)) {
value <- 0
for (j in 1:n_dim) {
if (cell[j] >= grid_instance$df_grid$id_cell[i, j]) {
value <- 1
} else {
value <- 0
break
}
}
phi[[i]] <- rep(value, length(outputs))
}
return(phi)
}
# Método para calcular el valor de la transformada de cada observación en el grid
grid_instance$calculate_df_grid <- function() {
phi_list <- list()
c_cells <- list()
for (i in 1:nrow(grid_instance$df_grid)) {
p <- grid_instance$search_dmu(as.list(grid_instance$df_grid$value[i, ]))
phi <- grid_instance$calculate_dmu_phi(p)
phi_list[[i]] <- phi
c_cell <- search_contiguous_cell(grid_instance$df_grid$id_cell[i, ])
c_cells[[i]] <- c_cell
}
grid_instance$df_grid$phi <- phi_list
grid_instance$df_grid$c_cells <- c_cells
}
# Método para calcular la transformada de cada observación en el grid
grid_instance$calculate_data_grid <- function() {
data_grid <- grid_instance$data
phi_list <- list()
c_cells <- list()
for (i in 1:nrow(data_grid)) {
x <- data_grid[i, inputs]
p <- grid_instance$search_dmu(as.list(x))
phi <- grid_instance$calculate_dmu_phi(p)
phi_list[[i]] <- phi
c_cell <- search_contiguous_cell(p)
c_cells[[i]] <- c_cell
}
data_grid$phi <- phi_list
data_grid$c_cells <- c_cells
grid_instance$data_grid <- data_grid
}
return(grid_instance)
}
# Método para buscar celdas contiguas
search_contiguous_cell <- function(cell) {
con_c_list <- list()
for (dim in seq_along(cell)) {
value <- cell[dim] - 1
con_cell <- cell
if (value >= 0) {
con_cell[dim] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
# Crear un conjunto de datos de ejemplo
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 1, 2),
y1 = c(2, 4, 3, 5)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj$create_grid()
# Cargar la clase grid y sus funciones asociadas
source("~/Documents/GitHub/svfpackage/R/grid.R")
# Definir la clase SVFGrid como una extensión de la clase GRID
SVFGrid <- function(data, inputs, outputs, d) {
# Llamar al constructor de la clase GRID
grid_instance <- GRID$data$new(data, inputs, outputs, d)
# Agregar atributos específicos de SVFGrid
grid_instance$df_grid <- NULL
grid_instance$knot_list <- NULL
# Métodos de la clase SVFGrid
# Método para crear el grid
grid_instance$create_grid <- function() {
x <- grid_instance$data[, inputs]
n_dim <- ncol(x)
knot_list <- vector("list", n_dim)
knot_index <- vector("list", n_dim)
# Calcula knot_list y knot_index
for (col in 1:n_dim) {
knot_min <- min(x[, col])
knot_max <- max(x[, col])
amplitud <- (knot_max - knot_min) / grid_instance$d
knot <- seq(knot_min, knot_max, by = amplitud)
knot_list[[col]] <- knot
knot_index[[col]] <- 0:grid_instance$d
}
# Genera todas las combinaciones de knot_index y knot_list
combinations <- expand.grid(knot_index)
knot_values <- do.call(expand.grid, knot_list)
# Combina manualmente las listas de knot_index y knot_list
grid_instance$df_grid <- data.frame(
id_cell = sapply(1:nrow(combinations), function(i) unlist(combinations[i,])),
value = sapply(1:nrow(knot_values), function(i) unlist(knot_values[i,]))
)
# Calcula la longitud de celdas contiguas
grid_instance$df_grid$c_cells <- sapply(grid_instance$df_grid$id_cell, search_contiguous_cell)
# Calcula la transformación phi
grid_instance$df_grid$phi <- apply(grid_instance$df_grid$id_cell, 1, function(x) calculate_dmu_phi(grid_instance, x))
grid_instance$knot_list <- knot_list
grid_instance$calculate_df_grid()
grid_instance$calculate_data_grid()
}
# Método para calcular la transformación de phi para una celda dada
grid_instance$calculate_dmu_phi <- function(cell) {
phi <- list()
n_dim <- length(cell)
for (i in 1:nrow(grid_instance$df_grid)) {
value <- 0
for (j in 1:n_dim) {
if (cell[j] >= grid_instance$df_grid$id_cell[i, j]) {
value <- 1
} else {
value <- 0
break
}
}
phi[[i]] <- rep(value, length(outputs))
}
return(phi)
}
# Método para calcular el valor de la transformada de cada observación en el grid
calculate_df_grid <- function(grid_instance) {
phi_list <- lapply(seq_len(nrow(grid_instance$df_grid)), function(i) {
p <- grid_instance$search_dmu(as.list(grid_instance$df_grid$value[i, ]))
grid_instance$calculate_dmu_phi(p)
})
c_cells <- lapply(seq_len(nrow(grid_instance$df_grid)), function(i) {
search_contiguous_cell(grid_instance$df_grid$id_cell[i, ])
})
grid_instance$df_grid$phi <- phi_list
grid_instance$df_grid$c_cells <- c_cells
}
# Método para calcular la transformada de cada observación en el grid
grid_instance$calculate_data_grid <- function() {
data_grid <- grid_instance$data
phi_list <- list()
c_cells <- list()
for (i in 1:nrow(data_grid)) {
x <- data_grid[i, inputs]
p <- grid_instance$search_dmu(as.list(x))
phi <- grid_instance$calculate_dmu_phi(p)
phi_list[[i]] <- phi
c_cell <- search_contiguous_cell(p)
c_cells[[i]] <- c_cell
}
data_grid$phi <- phi_list
data_grid$c_cells <- c_cells
grid_instance$data_grid <- data_grid
}
return(grid_instance)
}
# Método para buscar celdas contiguas
search_contiguous_cell <- function(cell) {
con_c_list <- list()
for (dim in seq_along(cell)) {
value <- cell[dim] - 1
con_cell <- cell
if (value >= 0) {
con_cell[dim] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
# Crear un conjunto de datos de ejemplo
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 1, 2),
y1 = c(2, 4, 3, 5)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj$create_grid()
# Cargar la clase grid y sus funciones asociadas
source("~/Documents/GitHub/svfpackage/R/grid.R")
# Definir la clase SVFGrid como una extensión de la clase GRID
SVFGrid <- function(data, inputs, outputs, d) {
# Llamar al constructor de la clase GRID
grid_instance <- GRID$data$new(data, inputs, outputs, d)
# Agregar atributos específicos de SVFGrid
grid_instance$df_grid <- NULL
grid_instance$knot_list <- NULL
# Métodos de la clase SVFGrid
# Método para crear el grid
grid_instance$create_grid <- function() {
x <- grid_instance$data[, inputs]
n_dim <- ncol(x)
knot_list <- vector("list", n_dim)
knot_index <- vector("list", n_dim)
# Calcula knot_list y knot_index
for (col in 1:n_dim) {
knot_min <- min(x[, col])
knot_max <- max(x[, col])
amplitud <- (knot_max - knot_min) / grid_instance$d
knot <- seq(knot_min, knot_max, by = amplitud)
knot_list[[col]] <- knot
knot_index[[col]] <- 0:grid_instance$d
}
# Genera todas las combinaciones de knot_index y knot_list
combinations <- expand.grid(knot_index)
knot_values <- do.call(expand.grid, knot_list)
# Combina manualmente las listas de knot_index y knot_list
grid_instance$df_grid <- data.frame(
id_cell = sapply(1:nrow(combinations), function(i) unlist(combinations[i,])),
value = sapply(1:nrow(knot_values), function(i) unlist(knot_values[i,]))
)
# Calcula la longitud de celdas contiguas
grid_instance$df_grid$c_cells <- sapply(grid_instance$df_grid$id_cell, search_contiguous_cell)
# Calcula la transformación phi
grid_instance$df_grid$phi <- apply(grid_instance$df_grid$id_cell, 1, function(x) calculate_dmu_phi(grid_instance, x))
grid_instance$knot_list <- knot_list
grid_instance$calculate_df_grid()
grid_instance$calculate_data_grid()
}
# Método para calcular la transformación de phi para una celda dada
grid_instance$calculate_dmu_phi <- function(cell) {
phi <- list()
n_dim <- length(cell)
for (i in 1:nrow(grid_instance$df_grid)) {
value <- 0
for (j in 1:n_dim) {
if (cell[j] >= grid_instance$df_grid$id_cell[i, j]) {
value <- 1
} else {
value <- 0
break
}
}
phi[[i]] <- rep(value, length(outputs))
}
return(phi)
}
# Método para calcular el valor de la transformada de cada observación en el grid
grid_instance$calculate_df_grid <- function() {
phi_list <- list()
c_cells <- list()
for (i in 1:nrow(grid_instance$df_grid)) {
p <- grid_instance$search_dmu(as.list(grid_instance$df_grid$value[i, ]))
phi <- grid_instance$calculate_dmu_phi(p)
phi_list[[i]] <- phi
c_cell <- search_contiguous_cell(grid_instance$df_grid$id_cell[i, ])
c_cells[[i]] <- c_cell
}
grid_instance$df_grid$phi <- phi_list
grid_instance$df_grid$c_cells <- c_cells
}
# Método para calcular la transformada de cada observación en el grid
grid_instance$calculate_data_grid <- function() {
data_grid <- grid_instance$data
phi_list <- list()
c_cells <- list()
for (i in 1:nrow(data_grid)) {
x <- data_grid[i, inputs]
p <- grid_instance$search_dmu(as.list(x))
phi <- grid_instance$calculate_dmu_phi(p)
phi_list[[i]] <- phi
c_cell <- search_contiguous_cell(p)
c_cells[[i]] <- c_cell
}
data_grid$phi <- phi_list
data_grid$c_cells <- c_cells
grid_instance$data_grid <- data_grid
}
return(grid_instance)
}
# Método para buscar celdas contiguas
search_contiguous_cell <- function(cell) {
con_c_list <- list()
for (dim in seq_along(cell)) {
value <- cell[dim] - 1
con_cell <- cell
if (value >= 0) {
con_cell[dim] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
# Crear un conjunto de datos de ejemplo
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 1, 2),
y1 = c(2, 4, 3, 5)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj$create_grid()
source("~/svfpackage/R/grid.R")
library(ggplot2)
# Usar el dataset de ejemplo
data <- read.table("~/svfpackage/data/datos.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Inicializar la cuadrícula
grid_instance <- initialize_GRID(data, inputs, outputs, d)
# Evaluar una observación menor que el valor del nodo del grid
result <- transformation(2, 5)
cat("Resultado de la transformación:", result, "\n")
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 3)
cat("Resultado de la transformación:", result, "\n")
# Evaluar una observación mayor que el valor del nodo del grid
result <- transformation(7, 4)
cat("Resultado de la transformación:", result, "\n")
# Ejemplo de uso de la función search_dmu
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- list(2.5, 1)
position <- search_dmu(grid_instance, dmu)
position_string <- paste(position, collapse = ", ")
cat("Posición en el grid:", position_string, "\n")
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, max(x_grid)), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
