}
cat("Solution for xi variables:\n")
for (out in seq_len(n_out)) {
print(mat_xi[[out]])
}
return(list(w = mat_w, xi = mat_xi))
}
# Crear y mostrar el objeto SVF
data <- data.frame(x1 = c(1, 2), x2 = c(1, 1), y1 = c(1, 4))
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y preparar el modelo
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve.SSVF(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)
library(dplyr)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
# Inicializar el modelo de optimización aquí
model <- MIPModel() %>%
add_variable(w[out, var], out = 1:n_out, var = 1:n_var, type = "continuous", lb = 0, ub = 1e+33) %>%
add_variable(xi[out, obs], out = 1:n_out, obs = 1:n_obs, type = "continuous", lb = 0, ub = 1e+33) %>%
set_objective(sum_expr(w[out, var] * 1, out = 1:n_out, var = 1:n_var) +
sum_expr(xi[out, obs] * svf$c, out = 1:n_out, obs = 1:n_obs), "min")
for (out in 1:n_out) {
for (obs in 1:n_obs) {
model <- model %>%
add_constraint(sum_expr(-w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) <= -y[obs, out]) %>%
add_constraint(sum_expr(w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) - xi[out, obs] <= y[obs, out] + svf$eps)
}
}
svf$model <- model
return(svf)
}
solve.SSVF <- function(svf) {
result <- solve_model(svf$model, with_ROI(solver = "glpk"))
w_solution <- result$solution[grep("^w", names(result$solution))]
xi_solution <- result$solution[grep("^xi", names(result$solution))]
n_out <- length(svf$outputs)
n_w_dim <- length(w_solution) / n_out
n_obs <- nrow(svf$data)
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_w_dim + 1
end_index <- out * n_w_dim
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
cat("Solution for w variables:\n")
for (out in seq_len(n_out)) {
print(mat_w[[out]])
}
cat("Solution for xi variables:\n")
for (out in seq_len(n_out)) {
print(mat_xi[[out]])
}
# Ordenar las soluciones para 'w' según el orden que necesitas
# Suponiendo que necesitas ordenar por los índices numéricos en los nombres de las variables
w_names <- names(w_solution)
w_order <- as.numeric(sub("w\\[(\\d+),\\d+\\]", "\\1", w_names))
w_sorted <- w_solution[order(w_order)]
# Presentar soluciones para w de manera estructurada
cat("Solution for w variables:\n")
for (out in 1:n_out) {
start_index <- (out - 1) * n_var + 1
end_index <- out * n_var
cat("[", paste(w_sorted[start_index:end_index], collapse=", "), "]\n")
}
# Si aún encuentras discrepancias, considera imprimir los nombres de las variables para verificar su orden
cat("Variable names in order for w:\n")
print(w_names[order(w_order)])
return(list(w = mat_w, xi = mat_xi))
}
# Crear y mostrar el objeto SVF
data <- data.frame(x1 = c(1, 2), x2 = c(1, 1), y1 = c(1, 4))
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y preparar el modelo
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve.SSVF(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)
library(dplyr)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
# Inicializar el modelo de optimización aquí
model <- MIPModel() %>%
add_variable(w[out, var], out = 1:n_out, var = 1:n_var, type = "continuous", lb = 0, ub = 1e+33) %>%
add_variable(xi[out, obs], out = 1:n_out, obs = 1:n_obs, type = "continuous", lb = 0, ub = 1e+33) %>%
set_objective(sum_expr(w[out, var] * 1, out = 1:n_out, var = 1:n_var) +
sum_expr(xi[out, obs] * svf$c, out = 1:n_out, obs = 1:n_obs), "min")
for (out in 1:n_out) {
for (obs in 1:n_obs) {
model <- model %>%
add_constraint(sum_expr(-w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) <= -y[obs, out]) %>%
add_constraint(sum_expr(w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) - xi[out, obs] <= y[obs, out] + svf$eps)
}
}
svf$model <- model
return(svf)
}
solve.SSVF <- function(svf) {
result <- solve_model(svf$model, with_ROI(solver = "glpk"))
cat("\\ This file has been generated by R ROI\n")
cat("\\ ENCODING=ISO-8859-1\n")
cat(sprintf("\\Problem name: SSVF C:%d, eps:%d, d:%d\n\n", svf$c, svf$eps, svf$d))
cat("Minimize\n obj:")
objective_vars <- names(result$solution)
cat(paste(objective_vars, collapse=" + "), "\n\n")
cat("Subject To\n")
constraints <- get_constraints(svf$model)
for (constraint in constraints) {
cat(constraint, "\n")
}
cat("\nBounds\n")
cat("End\n\n")
# Extraer y presentar las soluciones de forma estructurada
w_solution <- result$solution[grep("^w", names(result$solution))]
xi_solution <- result$solution[grep("^xi", names(result$solution))]
# Ordenar las soluciones para 'w' según el orden que necesitas
w_names <- names(w_solution)
w_order <- as.numeric(sub("w\\[(\\d+),\\d+\\]", "\\1", w_names))
w_sorted <- w_solution[order(w_order)]
# Calcular el número de variables w por output
n_out <- length(svf$outputs)
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
# Presentar soluciones para w de manera estructurada
cat("Solution for w variables:\n")
for (out in 1:n_out) {
start_index <- (out - 1) * n_var + 1
end_index <- out * n_var
cat("[", paste(w_sorted[start_index:end_index], collapse=", "), "]\n")
}
# Si deseas, imprime los nombres de las variables para verificar su orden
# print(w_names[order(w_order)])
# Presentar soluciones para xi de manera estructurada
n_obs <- nrow(svf$data)
cat("Solution for xi variables:\n")
for (out in 1:n_out) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
cat("[", paste(xi_solution[start_index:end_index], collapse=", "), "]\n")
}
return(result)
}
# Crear y mostrar el objeto SVF
data <- data.frame(x1 = c(1, 2), x2 = c(1, 1), y1 = c(1, 4))
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y preparar el modelo
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve.SSVF(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)
library(dplyr)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
# Inicializar el modelo de optimización aquí
model <- MIPModel() %>%
add_variable(w[out, var], out = 1:n_out, var = 1:n_var, type = "continuous", lb = 0, ub = 1e+33) %>%
add_variable(xi[out, obs], out = 1:n_out, obs = 1:n_obs, type = "continuous", lb = 0, ub = 1e+33) %>%
set_objective(sum_expr(w[out, var] * 1, out = 1:n_out, var = 1:n_var) +
sum_expr(xi[out, obs] * svf$c, out = 1:n_out, obs = 1:n_obs), "min")
for (out in 1:n_out) {
for (obs in 1:n_obs) {
model <- model %>%
add_constraint(sum_expr(-w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) <= -y[obs, out]) %>%
add_constraint(sum_expr(w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) - xi[out, obs] <= y[obs, out] + svf$eps)
}
}
svf$model <- model
return(svf)
}
solve.SSVF <- function(svf) {
result <- solve_model(svf$model, with_ROI(solver = "glpk"))
w_solution <- result$solution[grep("^w", names(result$solution))]
xi_solution <- result$solution[grep("^xi", names(result$solution))]
n_out <- length(svf$outputs)
n_w_dim <- length(w_solution) / n_out
n_obs <- nrow(svf$data)
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_w_dim + 1
end_index <- out * n_w_dim
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
cat("Solution for w variables:\n")
for (out in seq_len(n_out)) {
print(mat_w[[out]])
}
cat("Solution for xi variables:\n")
for (out in seq_len(n_out)) {
print(mat_xi[[out]])
}
return(list(w = mat_w, xi = mat_xi))
}
# Crear y mostrar el objeto SVF
data <- data.frame(x1 = c(1, 2), x2 = c(1, 1), y1 = c(1, 4))
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y preparar el modelo
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve.SSVF(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)
library(dplyr)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
# Inicializar el modelo de optimización aquí
model <- MIPModel() %>%
add_variable(w[out, var], out = 1:n_out, var = 1:n_var, type = "continuous", lb = 0, ub = 1e+33) %>%
add_variable(xi[out, obs], out = 1:n_out, obs = 1:n_obs, type = "continuous", lb = 0, ub = 1e+33) %>%
set_objective(sum_expr(w[out, var] * 1, out = 1:n_out, var = 1:n_var) +
sum_expr(xi[out, obs] * svf$c, out = 1:n_out, obs = 1:n_obs), "min")
for (out in 1:n_out) {
for (obs in 1:n_obs) {
model <- model %>%
add_constraint(sum_expr(-w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) <= -y[obs, out]) %>%
add_constraint(sum_expr(w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) - xi[out, obs] <= y[obs, out] + svf$eps)
}
}
svf$model <- model
return(svf)
}
solve.SSVF <- function(svf) {
result <- solve_model(svf$model, with_ROI(solver = "glpk"))
w_solution <- result$solution[grep("^w", names(result$solution))]
xi_solution <- result$solution[grep("^xi", names(result$solution))]
n_out <- length(svf$outputs)
n_w_dim <- length(w_solution) / n_out
n_obs <- nrow(svf$data)
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_w_dim + 1
end_index <- out * n_w_dim
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
cat("Solution for w variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf("[", out - 1), paste(mat_w[[out]], collapse=", "), "]\n")
}
cat("Solution for xi variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf("[", out - 1), paste(mat_xi[[out]], collapse=", "), "]\n")
}
return(list(w = mat_w, xi = mat_xi))
}
# Crear y mostrar el objeto SVF
data <- data.frame(x1 = c(1, 2), x2 = c(1, 1), y1 = c(1, 4))
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y preparar el modelo
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve.SSVF(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)
library(dplyr)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
# Inicializar el modelo de optimización aquí
model <- MIPModel() %>%
add_variable(w[out, var], out = 1:n_out, var = 1:n_var, type = "continuous", lb = 0, ub = 1e+33) %>%
add_variable(xi[out, obs], out = 1:n_out, obs = 1:n_obs, type = "continuous", lb = 0, ub = 1e+33) %>%
set_objective(sum_expr(w[out, var] * 1, out = 1:n_out, var = 1:n_var) +
sum_expr(xi[out, obs] * svf$c, out = 1:n_out, obs = 1:n_obs), "min")
for (out in 1:n_out) {
for (obs in 1:n_obs) {
model <- model %>%
add_constraint(sum_expr(-w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) <= -y[obs, out]) %>%
add_constraint(sum_expr(w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) - xi[out, obs] <= y[obs, out] + svf$eps)
}
}
svf$model <- model
return(svf)
}
solve.SSVF <- function(svf) {
result <- solve_model(svf$model, with_ROI(solver = "glpk"))
w_solution <- result$solution[grep("^w", names(result$solution))]
xi_solution <- result$solution[grep("^xi", names(result$solution))]
n_out <- length(svf$outputs)
n_w_dim <- length(w_solution) / n_out
n_obs <- nrow(svf$data)
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_w_dim + 1
end_index <- out * n_w_dim
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
cat("Solution for w variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [", out - 1), paste(mat_w[[out]], collapse=", "), "]\n")
}
cat("Solution for xi variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [", out - 1), paste(mat_xi[[out]], collapse=", "), "]\n")
}
return(list(w = mat_w, xi = mat_xi))
}
# Crear y mostrar el objeto SVF
data <- data.frame(x1 = c(1, 2), x2 = c(1, 1), y1 = c(1, 4))
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y preparar el modelo
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve.SSVF(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)
library(dplyr)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
# Inicializar el modelo de optimización aquí
model <- MIPModel() %>%
add_variable(w[out, var], out = 1:n_out, var = 1:n_var, type = "continuous", lb = 0, ub = 1e+33) %>%
add_variable(xi[out, obs], out = 1:n_out, obs = 1:n_obs, type = "continuous", lb = 0, ub = 1e+33) %>%
set_objective(sum_expr(w[out, var] * 1, out = 1:n_out, var = 1:n_var) +
sum_expr(xi[out, obs] * svf$c, out = 1:n_out, obs = 1:n_obs), "min")
for (out in 1:n_out) {
for (obs in 1:n_obs) {
model <- model %>%
add_constraint(sum_expr(-w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) <= -y[obs, out]) %>%
add_constraint(sum_expr(w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) - xi[out, obs] <= y[obs, out] + svf$eps)
}
}
svf$model <- model
return(svf)
}
solve.SSVF <- function(svf) {
result <- solve_model(svf$model, with_ROI(solver = "glpk"))
w_solution <- result$solution[grep("^w", names(result$solution))]
xi_solution <- result$solution[grep("^xi", names(result$solution))]
n_out <- length(svf$outputs)
n_w_dim <- length(w_solution) / n_out
n_obs <- nrow(svf$data)
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_w_dim + 1
end_index <- out * n_w_dim
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
cat("Solution for w variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" ["), paste(mat_w[[out]], collapse=", "), "]\n")
}
cat("Solution for xi variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" ["), paste(mat_xi[[out]], collapse=", "), "]\n")
}
return(list(w = mat_w, xi = mat_xi))
}
# Crear y mostrar el objeto SVF
data <- data.frame(x1 = c(1, 2), x2 = c(1, 1), y1 = c(1, 4))
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y preparar el modelo
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve.SSVF(trained_svf)
