svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(Rcplex)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
# Función modificada para crear y entrenar el modelo SSVF usando CPLEX
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
total_variables <- n_out * n_var + n_out * n_obs
cvec <- c(rep(1, n_out * n_var), rep(svf$c, n_out * n_obs))
Amat <- matrix(0, nrow = 2 * n_out * n_obs, ncol = total_variables)
bvec <- vector("numeric", length = 2 * n_out * n_obs)
sense <- rep("L", 2 * n_out * n_obs)
for (out in 1:n_out) {
for (obs in 1:n_obs) {
phi_vector <- svf$grid$data_grid$phi[[obs]][[out]]
row_index1 <- (out - 1) * 2 * n_obs + (obs - 1) * 2 + 1
row_index2 <- row_index1 + 1
w_indices <- ((out - 1) * n_var + 1):((out - 1) * n_var + n_var)
xi_index <- n_out * n_var + (out - 1) * n_obs + obs
Amat[row_index1, w_indices] <- -phi_vector
Amat[row_index2, w_indices] <- phi_vector
Amat[row_index2, xi_index] <- -1
bvec[row_index1] <- -y[obs, out]
bvec[row_index2] <- y[obs, out] + svf$eps
}
}
print("Matriz de Restricciones (Amat):")
print(Amat)
print("Vector del lado derecho (bvec):")
print(bvec)
print("Vector de sentido de las restricciones (sense):")
print(sense)
# Usar Rcplex para resolver el modelo
svf$model <- Rcplex(cvec = cvec, Amat = Amat, bvec = bvec, sense = sense, objsense = "min")
print("Modelo:")
print(svf$model)
return(svf)
}
# Función para extraer las soluciones utilizando CPLEX
solve <- function(svf) {
# Verificar si el modelo se resolvió correctamente
if (svf$model$status == 0) {
cat("Solution status: Optimal\n")
} else {
cat("Solution status: Solution not found or infeasible\n")
return(NULL)
}
# Extraer la solución del modelo
solution <- svf$model$xopt
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
n_out <- length(svf$outputs)
n_obs <- nrow(svf$data)
n_w_vars <- n_out * n_var
n_xi_vars <- n_out * n_obs
# Separar las soluciones para w y xi
w_solution <- solution[1:n_w_vars]
xi_solution <- solution[(n_w_vars + 1):(n_w_vars + n_xi_vars)]
# Formatear las soluciones para una mejor visualización
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_var + 1
end_index <- out * n_var
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
# Imprimir las soluciones para las variables w y xi
cat("Solution for w variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_w[[out]], collapse=", ")))
}
cat("Solution for xi variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_xi[[out]], collapse=", ")))
}
# Devolver una lista con las soluciones en caso de necesidad de procesamiento adicional
return(list(w = mat_w, xi = mat_xi))
}
# Usar datos de prueba
# data <- read.table("~/Documents/GitHub/svfpackage/data/datos3.txt", header = TRUE, sep = ";")
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(1, 3, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(Rcplex)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
# Función modificada para crear y entrenar el modelo SSVF usando CPLEX
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
total_variables <- n_out * n_var + n_out * n_obs
cvec <- c(rep(1, n_out * n_var), rep(svf$c, n_out * n_obs))
Amat <- matrix(0, nrow = 2 * n_out * n_obs, ncol = total_variables)
bvec <- vector("numeric", length = 2 * n_out * n_obs)
sense <- rep("L", 2 * n_out * n_obs)
for (out in 1:n_out) {
for (obs in 1:n_obs) {
phi_vector <- svf$grid$data_grid$phi[[obs]][[out]]
row_index1 <- (out - 1) * 2 * n_obs + (obs - 1) * 2 + 1
row_index2 <- row_index1 + 1
w_indices <- ((out - 1) * n_var + 1):((out - 1) * n_var + n_var)
xi_index <- n_out * n_var + (out - 1) * n_obs + obs
Amat[row_index1, w_indices] <- -phi_vector
Amat[row_index2, w_indices] <- phi_vector
Amat[row_index2, xi_index] <- -1
bvec[row_index1] <- -y[obs, out]
bvec[row_index2] <- y[obs, out] + svf$eps
}
}
print("Matriz de Restricciones (Amat):")
print(Amat)
print("Vector del lado derecho (bvec):")
print(bvec)
print("Vector de sentido de las restricciones (sense):")
print(sense)
# Usar Rcplex para resolver el modelo
svf$model <- Rcplex(cvec = cvec, Amat = Amat, bvec = bvec, sense = sense, objsense = "min")
print("Modelo:")
print(svf$model)
return(svf)
}
# Función para extraer las soluciones utilizando CPLEX
solve <- function(svf) {
# Verificar si el modelo se resolvió correctamente
if (svf$model$status == 1) {
cat("Solution status: Optimal\n")
} else {
cat("Solution status: Solution not found or infeasible\n")
return(NULL)
}
# Extraer la solución del modelo
solution <- svf$model$xopt
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
n_out <- length(svf$outputs)
n_obs <- nrow(svf$data)
n_w_vars <- n_out * n_var
n_xi_vars <- n_out * n_obs
# Separar las soluciones para w y xi
w_solution <- solution[1:n_w_vars]
xi_solution <- solution[(n_w_vars + 1):(n_w_vars + n_xi_vars)]
# Formatear las soluciones para una mejor visualización
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_var + 1
end_index <- out * n_var
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
# Imprimir las soluciones para las variables w y xi
cat("Solution for w variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_w[[out]], collapse=", ")))
}
cat("Solution for xi variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_xi[[out]], collapse=", ")))
}
# Devolver una lista con las soluciones en caso de necesidad de procesamiento adicional
return(list(w = mat_w, xi = mat_xi))
}
# Usar datos de prueba
# data <- read.table("~/Documents/GitHub/svfpackage/data/datos3.txt", header = TRUE, sep = ";")
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(1, 3, 2, 4))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(Rcplex)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
# Función modificada para crear y entrenar el modelo SSVF usando CPLEX
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df)
n_obs <- nrow(y_df)
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
total_variables <- n_out * n_var + n_out * n_obs
cvec <- c(rep(1, n_out * n_var), rep(svf$c, n_out * n_obs))
Amat <- matrix(0, nrow = 2 * n_out * n_obs, ncol = total_variables)
bvec <- vector("numeric", length = 2 * n_out * n_obs)
sense <- rep("L", 2 * n_out * n_obs)
for (out in 1:n_out) {
for (obs in 1:n_obs) {
phi_vector <- svf$grid$data_grid$phi[[obs]][[out]]
row_index1 <- (out - 1) * 2 * n_obs + (obs - 1) * 2 + 1
row_index2 <- row_index1 + 1
w_indices <- ((out - 1) * n_var + 1):((out - 1) * n_var + n_var)
xi_index <- n_out * n_var + (out - 1) * n_obs + obs
Amat[row_index1, w_indices] <- -phi_vector
Amat[row_index2, w_indices] <- phi_vector
Amat[row_index2, xi_index] <- -1
bvec[row_index1] <- -y[obs, out]
bvec[row_index2] <- y[obs, out] + svf$eps
}
}
print("Matriz de Restricciones (Amat):")
print(Amat)
print("Vector del lado derecho (bvec):")
print(bvec)
print("Vector de sentido de las restricciones (sense):")
print(sense)
# Usar Rcplex para resolver el modelo
svf$model <- Rcplex(cvec = cvec, Amat = Amat, bvec = bvec, sense = sense, objsense = "min")
return(svf)
}
# Función para extraer las soluciones utilizando CPLEX
solve <- function(svf) {
# Verificar si el modelo se resolvió correctamente
if (svf$model$status == 1) {
cat("Solution status: Optimal\n")
} else {
cat("Solution status: Solution not found or infeasible\n")
return(NULL)
}
# Extraer la solución del modelo
solution <- svf$model$xopt
n_var <- length(svf$grid$data_grid$phi[[1]][[1]])
n_out <- length(svf$outputs)
n_obs <- nrow(svf$data)
n_w_vars <- n_out * n_var
n_xi_vars <- n_out * n_obs
# Separar las soluciones para w y xi
w_solution <- solution[1:n_w_vars]
xi_solution <- solution[(n_w_vars + 1):(n_w_vars + n_xi_vars)]
# Formatear las soluciones para una mejor visualización
mat_w <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_var + 1
end_index <- out * n_var
mat_w[[out]] <- round(w_solution[start_index:end_index], 6)
}
mat_xi <- vector("list", n_out)
for (out in seq_len(n_out)) {
start_index <- (out - 1) * n_obs + 1
end_index <- out * n_obs
mat_xi[[out]] <- round(xi_solution[start_index:end_index], 6)
}
# Imprimir las soluciones para las variables w y xi
cat("Solution for w variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_w[[out]], collapse=", ")))
}
cat("Solution for xi variables:\n")
for (out in seq_len(n_out)) {
cat(sprintf(" [%s]\n", paste(mat_xi[[out]], collapse=", ")))
}
# Devolver una lista con las soluciones en caso de necesidad de procesamiento adicional
return(list(w = mat_w, xi = mat_xi))
}
# Usar datos de prueba
# data <- read.table("~/Documents/GitHub/svfpackage/data/datos3.txt", header = TRUE, sep = ";")
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(3, 2, 1, 5))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf_functions.R")
library(lpSolve)
library(dplyr)
# Usar datos de prueba
# data <- read.table("~/Documents/GitHub/svfpackage/data/datos3.txt", header = TRUE, sep = ";")
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(2, 4, 1, 5))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
print(svf)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf_functions.R")
library(Rceplex)
source("~/Documents/GitHub/svfpackage/R/svf_functions.R")
library(Rcplex)
# Usar datos de prueba
# data <- read.table("~/Documents/GitHub/svfpackage/data/datos3.txt", header = TRUE, sep = ";")
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(1, 3, 1, 2), y1 = c(2, 4, 1, 5))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
print(svf)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
library(Rcplex)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf_functions.R")
library(Rcplex)
# Usar datos de prueba
# data <- read.table("~/Documents/GitHub/svfpackage/data/datos3.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
print(svf)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
print_model <- function(svf) {
cat("\\ This file has been generated by R code\n")
cat("\\ ENCODING=ISO-8859-1\n")
cat(sprintf("\\Problem name: SSVF C:%s, eps:%s, d:%s\n\n", svf$c, svf$eps, svf$d))
cat("Minimize\n obj:")
for (i in 1:length(svf$model$obj)) {
if (i > 1) cat(" +")
cat(sprintf(" %s", names(svf$model$obj)[i]))
}
cat("\nSubject To\n")
for (i in 1:nrow(svf$model$Amat)) {
cat(sprintf(" c%d: ", i))
first <- TRUE
for (j in 1:ncol(svf$model$Amat)) {
coef <- svf$model$Amat[i, j]
if (coef != 0) {
if (!first && coef > 0) cat(" +")
cat(sprintf(" %g %s", coef, names(svf$model$obj)[j]))
first <- FALSE
}
}
cat(sprintf(" <= %g\n", svf$model$bvec[i]))
}
cat("\nBounds\n")
for (i in 1:length(svf$model$obj)) {
cat(sprintf(" %s free\n", names(svf$model$obj)[i]))
}
cat("End\n")
}
print_model(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf_functions.R")
library(Rcplex)
# Usar datos de prueba
# data <- read.table("~/Documents/GitHub/svfpackage/data/datos3.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
print(svf)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/svf_functions.R")
library(Rcplex)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos3.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
print(svf)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(ssvf)
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
library(Rcplex)
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos.txt", header = TRUE, sep = ";")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(ssvf)
print(trained_svf)
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
library(Rcplex)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(5, 6, 7, 8), y1 = c(9, 1, 2, 3))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(ssvf)
print(trained_svf)
source("~/Documents/GitHub/svfpackage/R/ssvf.R")
library(Rcplex)
# Usar datos de prueba
data <- data.frame(x1 = c(1, 2, 3, 4), x2 = c(5, 6, 7, 8), y1 = c(9, 1, 2, 3))
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
