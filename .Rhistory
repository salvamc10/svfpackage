plot_data <- data.frame(x = x_seq, y = estimations)
# Graficar con ggplot2
p <- ggplot(plot_data, aes(x = x, y = y)) +
geom_line(color = "blue", linewidth = 1) +
geom_point(data = svf$data, aes_string(x = input_col, y = output_col), color = "red") +
labs(title = "Frontera de Producción", x = input_col, y = output_col) +
theme_minimal()
print(p)
}
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Usar la función para graficar la frontera de producción
plot_production_frontier(svf_instance, "x1", "y1", d)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Usar la función para graficar la frontera de producción
plot_production_frontier(svf_instance, "x1", "y1", d)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Usar la función para graficar la frontera de producción
plot_production_frontier(svf_instance, "x1", "y1", d)
library(ggplot2)
#' Función que crea un objeto del tipo SVF en función del método que se selecciona
#'
#' Esta función es un constructor que permite crear diferentes tipos de objetos SVF.
#' Actualmente, solo soporta el tipo 'SSVF', pero puede ser extendida para incluir
#' otros tipos. Si el método especificado no es soportado, se producirá un error.
#'
#' @param method Método SVF que se quiere utilizar.
#' @param inputs Inputs a evaluar en el conjunto de datos.
#' @param outputs Outputs a evaluar en el conjunto de datos.
#' @param data Conjunto de datos a evaluar.
#' @param c Valores del hiperparámetro C del modelo.
#' @param eps Valores del hiperparámetro épsilon del modelo.
#' @param d Valor del hiperparámetro d del modelo.
#'
#' @return Devuelve un objeto del método SVF seleccionado.
#'
#' @export
create_SVF <- function(method, inputs, outputs, data, c, eps, d) {
if (method == "SSVF") {
svf <- SSVF(method, inputs, outputs, data, c, eps, d)
} else {
stop("The method selected doesn't exist")
}
return(svf)
}
#' Graficar la frontera de producción
#'
#' Esta función toma un objeto SVF entrenado y grafica la frontera de producción
#' para un solo input (x1) y un solo output (y1).
#'
#' @param svf Objeto de clase SVF entrenado.
#' @param input_col Nombre de la columna del input (x1).
#' @param output_col Nombre de la columna del output (y1).
#' @param d Valor fijo para los otros inputs que no se están graficando.
#' @param n_puntos Número de puntos a utilizar para la estimación.
#'
#' @export
plot_production_frontier <- function(svf, input_col, output_col, d, n_puntos = 100) {
if (!(input_col %in% colnames(svf$data)) || !(output_col %in% colnames(svf$data))) {
stop("El input o output especificado no existen en los datos.")
}
x_min <- min(svf$data[[input_col]])
x_max <- max(svf$data[[input_col]])
x_seq <- seq(x_min, x_max, length.out = n_puntos)
estimations <- sapply(x_seq, function(x) {
dmu <- c(x, d)
est <- get_estimation.SVF(svf, dmu)
return(est)
})
plot_data <- data.frame(x = x_seq, y = estimations)
p <- ggplot2(plot_data, aes(x = x, y = y)) +
geom_line(color = "blue", linewidth = 1) +
geom_point(data = svf$data, aes_string(x = input_col, y = output_col), color = "red") +
labs(title = "Frontera de Produccion", x = input_col, y = output_col) +
theme_minimal()
print(p)
}
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data <- read.table("~/Desktop/TFG_pruebas/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
grid_instance <- GRID(data, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(3, 4)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data <- read.table("svfpackage/data/datos2.txt", header = TRUE, sep = ";")
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data <- read.table("~/svfpackage/data/datos2.txt", header = TRUE, sep = ";")
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data <- read.table("~/data/datos2.txt", header = TRUE, sep = ";")
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data <- read.table("/data/datos2.txt", header = TRUE, sep = ";")
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data <- read.table("data/datos2.txt", header = TRUE, sep = ";")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
d <- 2
grid_instance <- GRID(data, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(3, 4)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
library(svfpackage)
# Usar datos de prueba
data <- read.table("data/datos2.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1", "y2")
C <- 1
eps <- 0
d <- 2
method <- 'SVF'
# Crear una instancia de la clase SVF
svf <- SVF(method, inputs, outputs, data, C, eps, d)
# Imprimir la instancia
print(svf)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- SSVF(method, inputs, outputs, data, C, eps, d)
# Entrenar el modelo
svf_instance <- train.SSVF(svf_instance)
# Exportar el modelo como cadena de texto
print(svf_instance$model)
# Resolver el modelo
solution <- solve.SSVF(svf_instance)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- SSVF(method, inputs, outputs, data, C, eps, d)
# Entrenar el modelo
svf_instance <- train.SSVF(svf_instance)
# Exportar el modelo como cadena de texto
print(svf_instance$model)
# Resolver el modelo
solution <- solve(svf_instance)
# Imprimir los resultados
for (i in seq_along(solution$w)) {
cat("w:", i, ":", paste(solution$w[[i]], collapse = ", "), "\n")
}
for (i in seq_along(solution$xi)) {
cat("xi:", i, ":", paste(solution$xi[[i]], collapse = ", "), "\n")
}
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- SSVF(method, inputs, outputs, data, C, eps, d)
# Entrenar el modelo
svf_instance <- train.SSVF(svf_instance)
# Exportar el modelo como cadena de texto
print(svf_instance$model)
# Resolver el modelo
solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- SSVF(method, inputs, outputs, data, C, eps, d)
# Entrenar el modelo
svf_instance <- train.SSVF(svf_instance)
# Exportar el modelo como cadena de texto
print(svf_instance$model)
# Resolver el modelo
solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(solution$w)
# Imprimir las soluciones de xi
print(solution$xi)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
# Entrenar el modelo
svf_instance <- train.SSVF(svf_instance)
# Exportar el modelo como cadena de texto
print(svf_instance$model)
# Resolver el modelo
solution <- solve.SSVF(svf_instance)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
# Entrenar el modelo
svf_instance <- train.SSVF(svf_instance)
# Exportar el modelo como cadena de texto
print(svf_instance$model)
# Resolver el modelo
solution <- solve(svf_instance)
print(solution)
library(svfpackage)
# Definir los datos
data <- data.frame(
x1 = c(1, 2, 3, 4),
x2 = c(1, 3, 2, 4),
y1 = c(1, 3, 2, 4)
)
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 3
# Parámetros iniciales del modelo SVF
C <- 1
eps <- 0
method <- 'SSVF'
# Instanciar y entrenar el modelo SVF
svf_instance <- create_SVF(method, inputs, outputs, data, C, eps, d)
svf_instance <- train.SSVF(svf_instance)
# Resolver el modelo y mostrar las soluciones
svf_solution <- solve(svf_instance)
# Imprimir las soluciones de w
print(svf_solution$w)
# Probar la función get_estimation
estimations <- list(
get_estimation.SVF(svf_instance, c(1, 2)),
get_estimation.SVF(svf_instance, c(3, 4)),
get_estimation.SVF(svf_instance, c(1, 7)),
get_estimation.SVF(svf_instance, c(7, 1)),
get_estimation.SVF(svf_instance, c(2, 4)),
get_estimation.SVF(svf_instance, c(7, 1))
)
# Imprimir las estimaciones
for (i in seq_along(estimations)) {
cat(sprintf("Estimación %d: %s\n", i + 1, estimations[[i]]))
}
# Usar la función para graficar la frontera de producción
plot_production_frontier(svf_instance, "x1", "y1", d)
# Crear un objeto SVFPrimalSolution con valores de ejemplo
w_values <- c(0.5, 1.5, 2.5)
xi_values <- c(0.1, 0.2, 0.3)
solution <- SVFPrimalSolution(w_values, xi_values)
# Verificar la clase del objeto
class(solution)
# Acceder a los atributos del objeto
solution$w
solution$xi
