# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
library(svfpackage)
library(Rcplex)
data(datos)
# Usar datos de prueba
data <- data(datos)
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
library(svfpackage)
library(Rcplex)
data(datos)
# Usar datos de prueba
data(datos)
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
library(svfpackage)
library(Rcplex)
# Usar datos de prueba
data(datos)
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
svf <- create_SVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
library(svfpackage)
library(Rcplex)
# Usar datos de prueba
data(datos)
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
library(svfpackage)
library(Rcplex)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
grid_instance <- GRID(data, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(4, 2)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
library(svfpackage)
library(Rcplex)
# Cargar datos de prueba directamente desde el paquete
data(datos, package = "svfpackage")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, datos, C, eps, d)  # Nota que ahora uso 'datos' en lugar de 'data'
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
print(solution_svf)  # Asegúrate de imprimir o de alguna manera mostrar los resultados
library(svfpackage)
library(Rcplex)
# Cargar datos de prueba directamente desde el paquete
data(datos, package = "svfpackage")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, datos, C, eps, d)  # Nota que ahora uso 'datos' en lugar de 'data'
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
print(solution_svf)  # Asegúrate de imprimir o de alguna manera mostrar los resultados
library(svfpackage)
library(Rcplex)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, data, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
library(svfpackage)
library(Rcplex)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, datos, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
print(solution_svf)
library(svfpackage)
library(Rcplex)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, datos, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
library(svfpackage)
library(Rcplex)
# Usar datos de prueba
data(datos2, package = "svfpackage")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, datos2, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
library(svfpackage)
library(Rcplex)
# Usar datos de prueba
data(datos3, package = "svfpackage")
# Definición de inputs, outputs y otros parámetros
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y mostrar el objeto SVF
ssvf <- SSVF(method, inputs, outputs, datos3, C, eps, d)
print(ssvf)
trained_svf <- train.SSVF(ssvf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve(trained_svf)
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
grid_instance <- GRID(datos, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(4, 2)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, data, dmu)
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
grid_instance <- GRID(datos, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(4, 2)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, datos, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- datos.frame(x = datos$x1, y = datos$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- datos.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(datos = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(datos = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, datos, dmu)
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
grid_instance <- GRID(datos, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(4, 2)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
library(svfpackage)
library(ggplot2)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Crear una instancia de GRID y usar sus métodos
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
grid_instance <- GRID(datos, inputs, outputs, d)
print(grid_instance)
# Evaluar una observación igual al valor del nodo del grid
result <- transformation(3, 2)
cat("Resultado de la transformación:", result, "\n")
grid_instance$knot_list <- list(list(1, 2.5, 4), list(1, 2, 3))
dmu <- c(4, 2)
position <- search_dmu.GRID(grid_instance, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Función para graficar el grid
plot_GRID <- function(grid_instance, data, dmu) {
# Extraer las coordenadas del grid
x_grid <- unlist(grid_instance$knot_list[[1]])
y_grid <- unlist(grid_instance$knot_list[[2]])
# Crear un dataframe con los puntos del grid
grid_df <- expand.grid(x = x_grid, y = y_grid)
# Crear un dataframe con las coordenadas de los datos
data_df <- data.frame(x = data$x1, y = data$x2)
# Convertir las coordenadas de la DMU en un dataframe
dmu_df <- data.frame(x = unlist(dmu[[1]]), y = unlist(dmu[[2]]))
# Crear un gráfico
p <- ggplot() +
# Añadir los datos
geom_point(data = data_df, aes(x = x, y = y), color = "blue", size = 3) +
# Añadir la DMU
geom_point(data = dmu_df, aes(x = x, y = y), color = "red", size = 3) +
# Añadir líneas verticales y horizontales para el grid
geom_vline(xintercept = x_grid, linetype = "dotted", color = "blue") +
geom_hline(yintercept = y_grid, linetype = "dotted", color = "blue") +
# Especificar límites del gráfico y ajustar la separación en los ejes x e y
coord_cartesian(xlim = c(0, 5), ylim = c(0, 4)) +
scale_x_continuous(expand = expansion(add = c(0, 0.1))) +
scale_y_continuous(expand = expansion(add = c(0, 0.1))) +
# Agregar borde alrededor del gráfico
theme(
plot.margin = margin(1, 1, 1, 1, "cm"),
panel.border = element_rect(color = "black", linewidth = 0.5, fill = NA)
)
# Configuraciones adicionales
labs(x = "x1", y = "x2", title = "Grid con Inputs y DMU") +
theme_minimal()
return(p)
}
# Graficar el grid con los datos y la DMU
plot_GRID(grid_instance, datos, dmu)
library(svfpackage)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
C <- 1
eps <- 0
d <- 2
method <- 'SVF'
# Crear una instancia de la clase SVF
svf <- SVF(method, inputs, outputs, datos, C, eps, d)
# Imprimir la instancia
print(svf)
library(svfpackage)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
C <- 1
eps <- 0
d <- 2
method <- 'SVF'
# Crear una instancia de la clase SVF
svf <- SVF(method, inputs, outputs, datos, C, eps, d)
# Imprimir la instancia
print(svf)
library(svfpackage)
# Usar datos de prueba
data(datos, package = "svfpackage")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(datos, inputs, outputs, d)
grid_obj <- create_grid.SVFGrid(grid_obj)
# Imprimimos la knot_list
cat("knot_list:\n")
for (i in seq_along(grid_obj$knot_list)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_list)[i], "): "),
paste(sprintf("%.1f", grid_obj$knot_list[[i]]), collapse = ", "), "\n")
}
# Realizar una búsqueda en el grid para una observación
dmu <- c(1, 3 )
position <- search_dmu.GRID(grid_obj, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Ejemplo de búsqueda de celda contigua
cell <- c(1, 1)
contiguous_cells <- search_contiguous_cell(cell)
print(paste("Celdas contiguas: (", paste(contiguous_cells, collapse = ", "), ")", sep = ""))
# Ejemplo del calculo de phi para una celda dada
cell <- c(0, 0)
phi_list <- calculate_dmu_phi(grid_obj, cell)
print("Vector phi para la celda dada:")
print(phi_list)
print_df_grid <- function(df_grid) {
print("DF grid completo:")
temp_df <- data.frame(
id_cell = apply(df_grid$id_cells, 1, function(row) paste0("(", paste(row, collapse = ", "), ")")),
value = apply(df_grid$values, 1, function(row) paste0("(", paste(sprintf("%.1f", row), collapse = ", "), ")")),
phi = sapply(df_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse=" "))),
c_cells = sapply(df_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_df_grid(grid_obj$df_grid)
print_data_grid <- function(data_grid) {
print("Data grid completo:")
temp_df <- data.frame(
x1 = data_grid$x1,
x2 = data_grid$x2,
phi = sapply(data_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse = " "))),
c_cells = sapply(data_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_data_grid(grid_obj$data_grid)
usethis::github_action_check_standard()
usethis::use_github_action_check_standard()
usethis::use_github_action()
usethis::use_github_action()
gitcreds::gitcreds_set()
usethis::create_github_token()
gitcreds::gitcreds_set()
usethis::use_github_action()
