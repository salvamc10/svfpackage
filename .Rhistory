}
}
phi[i] <- value
}
phi_list <- list(phi)
return(phi_list)
}
#' Método para añadir al dataframe grid el valor de la transformada de cada observación
#'
#' Este método calcula y añade información adicional al dataframe de grid
#' asociado a un objeto SVFGrid. Esta información incluye los valores de phi
#' para cada celda del grid y las celdas contiguas a cada celda.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return El objeto SVFGrid con el dataframe de grid actualizado.
#'
#' @example examples/example_df.R
#'
#' @export
calculate_df_grid <- function(grid) {
n <- nrow(grid$df_grid$id_cells)
phi_list <- vector("list", n)
c_cells_list <- vector("list", n)
for (i in 1:n) {
cell <- grid$df_grid$values[i, , drop = FALSE]
p <- search_dmu.GRID(grid, cell)
phi <- calculate_dmu_phi(grid, p)[[1]]
c_cells <- search_contiguous_cell(p)
phi_list[[i]] <- list(phi)
c_cells_list[[i]] <- c_cells
}
grid$df_grid$phi <- phi_list
grid$df_grid$c_cells <- c_cells_list
return(grid)
}
#' Método para añadir al dataframe grid el valor de la transformada de cada observación
#'
#' Esta función procesa cada observación del data_grid basándose en las columnas especificadas en inputs,
#' calculando valores phi y celdas contiguas (c_cells) y actualizando el objeto grid con estos resultados.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return 0bjeto grid modificado con los resultados de phi y c_cells añadidos.
#'
#' @example examples/example_data.R
#'
#' @export
calculate_data_grid <- function(grid) {
grid$data_grid <- grid$data[, grid$inputs, drop = FALSE]
phi_list <- list()
c_cells_list <- list()
for (i in seq_len(nrow(grid$data_grid))) {
x <- as.numeric(grid$data_grid[i, ])
p <- search_dmu.GRID(grid, x)
phi <- calculate_dmu_phi(grid, p)
phi_list[[i]] <- phi
c_cells <- search_contiguous_cell(p)
c_cells_list[[i]] <- c_cells
}
grid$data_grid$phi <- phi_list
grid$data_grid$c_cells <- c_cells_list
return(grid)
}
#' Buscar celdas contiguas en SVFGrid
#'
#' Esta función identifica y retorna las celdas contiguas a una celda especificada
#' en el grid. Las celdas contiguas son aquellas que comparten al menos un borde
#' o punto con la celda especificada.
#'
#' @param cell Vector que especifica la posición de la celda en el grid.
#'
#' @return Una lista de celdas contiguas a la especificada.
#'
#' @example examples/example_contiguous.R
#'
#' @export
search_contiguous_cell <- function(cell) {
con_c_list <- list()
for (dim in seq_along(cell)) {
value <- cell[dim] - 1
if (value >= 0) {
con_cell <- cell
con_cell[dim] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj <- create_grid.SVFGrid(grid_obj)
# Imprimimos la knot_list
cat("knot_list:\n")
for (i in seq_along(grid_obj$knot_list)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_list)[i], "): "),
paste(sprintf("%.1f", grid_obj$knot_list[[i]]), collapse = ", "), "\n")
}
# Imprimimos el knot_index
cat("\nknot_index:\n")
for (i in seq_along(grid_obj$knot_index)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_index)[i], "): "),
paste(grid_obj$knot_index[[i]], collapse = ", "), "\n")
}
# Realizar una búsqueda en el grid para una observación
dmu <- c(1, 1 )
position <- search_dmu.GRID(grid_obj, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Ejemplo de búsqueda de celda contigua
cell <- c(1, 1)
contiguous_cells <- search_contiguous_cell(cell)
print(paste("Celdas contiguas: (", paste(contiguous_cells, collapse = ", "), ")", sep = ""))
# Ejemplo del calculo de phi para una celda dada
cell <- c(0, 0)
phi_list <- calculate_dmu_phi(grid_obj, cell)
print("Vector phi para la celda dada:")
print(phi_list)
print_df_grid <- function(df_grid) {
print("DF grid completo:")
temp_df <- data.frame(
id_cell = apply(df_grid$id_cells, 1, function(row) paste0("(", paste(row, collapse = ", "), ")")),
value = apply(df_grid$values, 1, function(row) paste0("(", paste(sprintf("%.1f", row), collapse = ", "), ")")),
phi = sapply(df_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse=" "))),
c_cells = sapply(df_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_df_grid(grid_obj$df_grid)
print_data_grid <- function(data_grid) {
print("Data grid completo:")
temp_df <- data.frame(
x1 = data_grid$x1,
x2 = data_grid$x2,
phi = sapply(data_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse = " "))),
c_cells = sapply(data_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_data_grid(grid_obj$data_grid)
source("~/Documents/GitHub/svfpackage/R/grid.R")
#' Constructor para la clase SVFGrid
#'
#' Esta función crea una instancia de la clase SVFGrid, la cual es una
#' extensión de la clase GRID con funcionalidades adicionales específicas
#' para el manejo de grids en el contexto de análisis SVF.
#'
#' @param data Conjunto de datos sobre los que se construye el grid.
#' @param inputs Listado de inputs.
#' @param outputs Listado de outputs.
#' @param d Número de particiones en las que se divide el grid.
#'
#' @return Un objeto de clase SVFGrid.
#'
#' @example examples/example_svfgrid.R
#'
#' @export
SVFGrid <- function(data, inputs, outputs, d) {
grid <- list(data = data, inputs = inputs, outputs = outputs, d = d, df_grid = data.frame(), data_grid = data.frame())
class(grid) <- c("SVFGrid", "GRID")
return(grid)
}
#' Función que crea un grid en base a unos datos e hiperparámetro d
#'
#' Este método crea un grid basado en los datos y el parámetro d proporcionados
#' al constructor. Este grid es una representación de los datos en un espacio
#' dividido en celdas definidas por el parámetro d.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return El objeto SVFGrid con el grid creado.
#'
#' @example examples/example_create_grid.R
#'
#' @export
create_grid.SVFGrid <- function(grid) {
x <- grid$data[, grid$inputs]
n_dim <- ncol(x)
knot_list <- list()
knot_index <- list()
for (col in seq_len(n_dim)) {
knot_min <- min(x[, col], na.rm = TRUE)
knot_max <- max(x[, col], na.rm = TRUE)
amplitud <- (knot_max - knot_min) / grid$d
knots <- seq(knot_min, knot_max, length.out = grid$d + 1)
knot_list[[col]] <- knots
knot_index[[col]] <- 1:(grid$d+1)
}
grid$knot_list <- knot_list
id_cells <- expand.grid(knot_index)
id_cells <- id_cells[, ncol(id_cells):1]
values <- expand.grid(rev(knot_list))
values <- values[, ncol(values):1]
grid$df_grid <- list(id_cells = id_cells, values = values, phi = vector("list", nrow(values)))
grid <- calculate_df_grid(grid)
grid <- calculate_data_grid(grid)
return(grid)
}
#' Función que calcula el valor de la transformación (phi) de una observación en el grid.
#'
#' Esta función calcula y retorna el valor de phi para una celda específica del
#' grid, basado en los datos del grid y la posición de la celda.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#' @param cell Posición de la observación en el grid.
#'
#' @return Una lista que contiene los valores de phi para la celda especificada.
#'
#' @example examples/example_phi.R
#'
#' @export
calculate_dmu_phi <- function(grid, cell) {
df_grid <- grid$df_grid
phi <- numeric(length = nrow(df_grid$id_cells))
for (i in seq_len(nrow(df_grid$id_cells))) {
value <- 1
for (j in seq_along(cell)) {
if (cell[j] < df_grid$id_cells[i, j]) {
value <- 0
break
}
}
phi[i] <- value
}
phi_list <- list(phi)
return(phi_list)
}
#' Método para añadir al dataframe grid el valor de la transformada de cada observación
#'
#' Este método calcula y añade información adicional al dataframe de grid
#' asociado a un objeto SVFGrid. Esta información incluye los valores de phi
#' para cada celda del grid y las celdas contiguas a cada celda.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return El objeto SVFGrid con el dataframe de grid actualizado.
#'
#' @example examples/example_df.R
#'
#' @export
calculate_df_grid <- function(grid) {
n <- nrow(grid$df_grid$id_cells)
phi_list <- vector("list", n)
c_cells_list <- vector("list", n)
for (i in 1:n) {
cell <- grid$df_grid$values[i, , drop = FALSE]
p <- search_dmu.GRID(grid, cell)
phi <- calculate_dmu_phi(grid, p)[[1]]
c_cells <- search_contiguous_cell(p)
phi_list[[i]] <- list(phi)
c_cells_list[[i]] <- c_cells
}
grid$df_grid$phi <- phi_list
grid$df_grid$c_cells <- c_cells_list
return(grid)
}
#' Método para añadir al dataframe grid el valor de la transformada de cada observación
#'
#' Esta función procesa cada observación del data_grid basándose en las columnas especificadas en inputs,
#' calculando valores phi y celdas contiguas (c_cells) y actualizando el objeto grid con estos resultados.
#'
#' @param grid Objeto SVFGrid sobre el cual operar.
#'
#' @return 0bjeto grid modificado con los resultados de phi y c_cells añadidos.
#'
#' @example examples/example_data.R
#'
#' @export
calculate_data_grid <- function(grid) {
grid$data_grid <- grid$data[, grid$inputs, drop = FALSE]
phi_list <- list()
c_cells_list <- list()
for (i in seq_len(nrow(grid$data_grid))) {
x <- as.numeric(grid$data_grid[i, ])
p <- search_dmu.GRID(grid, x)  # Aquí se busca la celda correspondiente
phi <- calculate_dmu_phi(grid, p)  # Aquí se calcula el phi
phi_list[[i]] <- phi
c_cells <- search_contiguous_cell(p)  # Aquí se busca las celdas contiguas
c_cells_list[[i]] <- c_cells
}
grid$data_grid$phi <- phi_list
grid$data_grid$c_cells <- c_cells_list
return(grid)
}
#' Buscar celdas contiguas en SVFGrid
#'
#' Esta función identifica y retorna las celdas contiguas a una celda especificada
#' en el grid. Las celdas contiguas son aquellas que comparten al menos un borde
#' o punto con la celda especificada.
#'
#' @param cell Vector que especifica la posición de la celda en el grid.
#'
#' @return Una lista de celdas contiguas a la especificada.
#'
#' @example examples/example_contiguous.R
#'
#' @export
search_contiguous_cell <- function(cell) {
con_c_list <- list()
for (dim in seq_along(cell)) {
value <- cell[dim]
if (value >= 0) {
con_cell <- cell
con_cell[dim] <- value
con_c_list <- c(con_c_list, list(con_cell))
}
}
return(con_c_list)
}
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj <- create_grid.SVFGrid(grid_obj)
# Imprimimos la knot_list
cat("knot_list:\n")
for (i in seq_along(grid_obj$knot_list)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_list)[i], "): "),
paste(sprintf("%.1f", grid_obj$knot_list[[i]]), collapse = ", "), "\n")
}
# Imprimimos el knot_index
cat("\nknot_index:\n")
for (i in seq_along(grid_obj$knot_index)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_index)[i], "): "),
paste(grid_obj$knot_index[[i]], collapse = ", "), "\n")
}
# Realizar una búsqueda en el grid para una observación
dmu <- c(1, 1 )
position <- search_dmu.GRID(grid_obj, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Ejemplo de búsqueda de celda contigua
cell <- c(1, 1)
contiguous_cells <- search_contiguous_cell(cell)
print(paste("Celdas contiguas: (", paste(contiguous_cells, collapse = ", "), ")", sep = ""))
# Ejemplo del calculo de phi para una celda dada
cell <- c(0, 0)
phi_list <- calculate_dmu_phi(grid_obj, cell)
print("Vector phi para la celda dada:")
print(phi_list)
print_df_grid <- function(df_grid) {
print("DF grid completo:")
temp_df <- data.frame(
id_cell = apply(df_grid$id_cells, 1, function(row) paste0("(", paste(row, collapse = ", "), ")")),
value = apply(df_grid$values, 1, function(row) paste0("(", paste(sprintf("%.1f", row), collapse = ", "), ")")),
phi = sapply(df_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse=" "))),
c_cells = sapply(df_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_df_grid(grid_obj$df_grid)
print_data_grid <- function(data_grid) {
print("Data grid completo:")
temp_df <- data.frame(
x1 = data_grid$x1,
x2 = data_grid$x2,
phi = sapply(data_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse = " "))),
c_cells = sapply(data_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_data_grid(grid_obj$data_grid)
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
# Usar datos de prueba
data <- read.table("~/Documents/GitHub/svfpackage/data/datos.txt", header = TRUE, sep = ";")
# Definir listas de inputs, outputs y la cantidad de particiones
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
# Crear la instancia de la clase SVFGrid y llamar al método create_grid
grid_obj <- SVFGrid(data, inputs, outputs, d)
grid_obj <- create_grid.SVFGrid(grid_obj)
# Imprimimos la knot_list
cat("knot_list:\n")
for (i in seq_along(grid_obj$knot_list)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_list)[i], "): "),
paste(sprintf("%.1f", grid_obj$knot_list[[i]]), collapse = ", "), "\n")
}
# Imprimimos el knot_index
cat("\nknot_index:\n")
for (i in seq_along(grid_obj$knot_index)) {
cat(paste0("Dimensión ", i, " (", names(grid_obj$knot_index)[i], "): "),
paste(grid_obj$knot_index[[i]], collapse = ", "), "\n")
}
# Realizar una búsqueda en el grid para una observación
dmu <- c(1, 1 )
position <- search_dmu.GRID(grid_obj, dmu)
print(paste("Posición en el grid: (", paste(position, collapse = ", "), ")", sep = ""))
# Ejemplo de búsqueda de celda contigua
cell <- c(1, 1)
contiguous_cells <- search_contiguous_cell(cell)
print(paste("Celdas contiguas: (", paste(contiguous_cells, collapse = ", "), ")", sep = ""))
# Ejemplo del calculo de phi para una celda dada
cell <- c(0, 0)
phi_list <- calculate_dmu_phi(grid_obj, cell)
print("Vector phi para la celda dada:")
print(phi_list)
print_df_grid <- function(df_grid) {
print("DF grid completo:")
temp_df <- data.frame(
id_cell = apply(df_grid$id_cells, 1, function(row) paste0("(", paste(row, collapse = ", "), ")")),
value = apply(df_grid$values, 1, function(row) paste0("(", paste(sprintf("%.1f", row), collapse = ", "), ")")),
phi = sapply(df_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse=" "))),
c_cells = sapply(df_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_df_grid(grid_obj$df_grid)
print_data_grid <- function(data_grid) {
print("Data grid completo:")
temp_df <- data.frame(
x1 = data_grid$x1,
x2 = data_grid$x2,
phi = sapply(data_grid$phi, function(phi) sprintf("[%s]", paste(phi[[1]], collapse = " "))),
c_cells = sapply(data_grid$c_cells, function(cells) if (length(cells) > 0) paste(sapply(cells, function(cell) paste0("(", paste(cell, collapse = ", "), ")")), collapse = " ") else "[]")
)
print(temp_df)
}
print_data_grid(grid_obj$data_grid)
source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")
library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)
library(dplyr)
SSVF <- function(method, inputs, outputs, data, c, eps, d) {
svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
class(svf) <- c("SSVF", "SVF")
return(svf)
}
train.SSVF <- function(svf) {
y_df <- svf$data[, svf$outputs, drop = FALSE]
y <- as.matrix(y_df)
n_out <- ncol(y_df) - 1
n_obs <- nrow(y_df) - 1
svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))
n_var <- length(svf$grid$data_grid$phi[[1]][[1]]) - 1
# Inicializar el modelo de optimización aquí
model <- MIPModel() %>%
add_variable(w[out, var], out = 0:n_out, var = 0:n_var, type = "continuous", lb = 0, ub = 1e+33) %>%
add_variable(xi[out, obs], out = 0:n_out, obs = 0:n_obs, type = "continuous", lb = 0, ub = 1e+33) %>%
set_objective(sum_expr(w[out, var] * 1, out = 0:n_out, var = 0:n_var) +
sum_expr(xi[out, obs] * svf$c, out = 0:n_out, obs = 0:n_obs), "min")
for (out in 0:n_out) {
for (obs in 0:n_obs) {
model <- model %>%
add_constraint(sum_expr(-w[out, var] * svf$grid$data_grid$phi[[obs + 1]][[out + 1]][var + 1], var = 0:n_var) <= -y[obs + 1, out + 1]) %>%
add_constraint(sum_expr(w[out, var] * svf$grid$data_grid$phi[[obs + 1]][[out + 1]][var + 1], var = 0:n_var) - xi[out, obs] <= y[obs + 1, out + 1] + svf$eps)
}
}
svf$model <- model
return(svf)
}
solve.SSVF <- function(svf) {
result <- solve_model(svf$model, with_ROI(solver = "glpk"))
cat("\\ This file has been generated by R ROI\n")
cat("\\ ENCODING=ISO-8859-1\n")
cat(sprintf("\\Problem name: SSVF C:%d, eps:%d, d:%d\n\n", svf$c, svf$eps, svf$d))
cat("Minimize\n obj:")
objective_vars <- names(result$solution)
cat(paste(objective_vars, collapse=" + "), "\n\n")
cat("Subject To\n")
constraints <- get_constraints(svf$model)
for (i in seq_along(constraints)) {
cat(sprintf(" c%d: %s\n", i, deparse(constraints[[i]])))
}
cat("\nBounds\n")
cat("End\n\n")
cat("Soluciones para w:\n")
w_solution <- result$solution[grep("^w", names(result$solution))]
cat("Output 0: [", paste(w_solution, collapse=", "), "]\n\n")
cat("Soluciones para xi:\n")
xi_solution <- result$solution[grep("^xi", names(result$solution))]
cat("Output 0: [", paste(xi_solution, collapse=", "), "]\n")
return(result)
}
get_constraints <- function(model) {
constraints <- list()
if ("constraints" %in% names(model)) {
for (i in seq_along(model$constraints)) {
lhs <- paste(names(model$constraints[[i]]$lhs), collapse=" + ")
rhs <- model$constraints[[i]]$rhs
sense <- model$constraints[[i]]$sense
constraints[[paste0("c", i)]] <- sprintf("%s %s %s", lhs, ifelse(sense == "<=", "<=", "="), rhs)
}
}
return(constraints)
}
# Crear y mostrar el objeto SVF
data <- data.frame(x1 = c(1, 2), x2 = c(1, 1), y1 = c(1, 4))
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'
# Crear y preparar el modelo
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)
# Resolver el modelo y mostrar resultados
solution_svf <- solve.SSVF(trained_svf)
