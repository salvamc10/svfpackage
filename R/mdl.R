source("~/Documents/GitHub/svfpackage/R/svf.R")
source("~/Documents/GitHub/svfpackage/R/svfgrid.R")

library(ROI)
library(ROI.plugin.glpk)
library(ompr)
library(ompr.roi)
library(dplyr)

SSVF <- function(method, inputs, outputs, data, c, eps, d) {
  svf <- list(method = method, inputs = inputs, outputs = outputs, data = data, c = c, eps = eps, d = d)
  class(svf) <- c("SSVF", "SVF")
  return(svf)
}

train.SSVF <- function(svf) {
  y_df <- svf$data[, svf$outputs, drop = FALSE]
  y <- as.matrix(y_df)

  n_out <- ncol(y_df)
  n_obs <- nrow(y_df)

  svf$grid <- create_grid.SVFGrid(SVFGrid(svf$data, svf$inputs, svf$outputs, svf$d))

  print("Matriz phi en R:")
  for (obs in 1:length(svf$grid$data_grid$phi)) {
    for (out in 1:length(svf$grid$data_grid$phi[[obs]])) {
      print(svf$grid$data_grid$phi[[obs]][[out]])
    }
  }

  n_var <- length(svf$grid$data_grid$phi[[1]][[1]])

  # Inicializar el modelo de optimización aquí
  model <- MIPModel() %>%
    add_variable(w[out, var], out = 1:n_out, var = 1:n_var, type = "continuous", lb = 0, ub = 1e+33) %>%
    add_variable(xi[out, obs], out = 1:n_out, obs = 1:n_obs, type = "continuous", lb = 0, ub = 1e+33) %>%
    set_objective(sum_expr(w[out, var] * 1, out = 1:n_out, var = 1:n_var) +
                    sum_expr(xi[out, obs] * svf$c, out = 1:n_out, obs = 1:n_obs), "min")

  for (out in 1:n_out) {
    for (obs in 1:n_obs) {
      model <- model %>%
        add_constraint(sum_expr(-w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) <= -y[obs, out]) %>%
        add_constraint(sum_expr(w[out, var] * svf$grid$data_grid$phi[[obs]][[out]][var], var = 1:n_var) - xi[out, obs] <= y[obs, out] + svf$eps)
    }
  }

  svf$model <- model

  return(svf)
}

solve.SSVF <- function(svf) {
  result <- solve_model(svf$model, with_ROI(solver = "glpk"))

  cat("\\ This file has been generated by R ROI\n")
  cat("\\ ENCODING=ISO-8859-1\n")
  cat(sprintf("\\Problem name: SSVF C:%d, eps:%d, d:%d\n\n", svf$c, svf$eps, svf$d))

  cat("Minimize\n obj:")
  objective_vars <- names(result$solution)
  cat(paste(objective_vars, collapse=" + "), "\n\n")

  cat("Subject To\n")
  constraints <- get_constraints(svf$model)
  for (i in seq_along(constraints)) {
    cat(sprintf(" c%d: %s\n", i, deparse(constraints[[i]])))
  }
  cat("\nBounds\n")

  cat("End\n\n")

  cat("Soluciones para w:\n")
  w_solution <- result$solution[grep("^w", names(result$solution))]
  cat("Output 0: [", paste(w_solution, collapse=", "), "]\n\n")

  cat("Soluciones para xi:\n")
  xi_solution <- result$solution[grep("^xi", names(result$solution))]
  cat("Output 0: [", paste(xi_solution, collapse=", "), "]\n")

  return(result)
}

get_constraints <- function(model) {
  constraints <- list()
  if ("constraints" %in% names(model)) {
    for (i in seq_along(model$constraints)) {
      lhs <- paste(names(model$constraints[[i]]$lhs), collapse=" + ")
      rhs <- model$constraints[[i]]$rhs
      sense <- model$constraints[[i]]$sense
      constraints[[paste0("c", i)]] <- sprintf("%s %s %s", lhs, ifelse(sense == "<=", "<=", "="), rhs)
    }
  }
  return(constraints)
}

# Crear y mostrar el objeto SVF
data <- data.frame(x1 = c(1, 2), x2 = c(1, 1), y1 = c(1, 4))
inputs <- c("x1", "x2")
outputs <- c("y1")
d <- 2
C <- 1
eps <- 0
method <- 'SSVF'

# Crear y preparar el modelo
svf <- SSVF(method, inputs, outputs, data, C, eps, d)
trained_svf <- train.SSVF(svf)

# Resolver el modelo y mostrar resultados
solution_svf <- solve.SSVF(trained_svf)
